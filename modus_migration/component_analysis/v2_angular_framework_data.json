{
  "documentation": "import { Meta } from '@storybook/blocks';\n\n<Meta title=\"Documentation/Frameworks/Angular\" />\n\n# Angular Framework Integration\n\nThis guide will help you get started with consuming the Modus Angular Web Component library in your Angular project.\n\nWe highly recommend using the Modus Angular Components library for Angular based projects.\nThese components are automatically generated using the Stencil Angular Framework Integration.\n\nFollow the steps outlined below to integrate and use Modus Angular Web Components effectively.\n\nPlease refer to the [official stencil documentation](https://stenciljs.com/docs/angular#consumer-usage) for more information on how to integrate with your Angular project.\n\n## Angular with modules\n\nModus Angular Components have a peer dependency with Modus Web Components and require the\ninstallation of both packages.\n\n### 1. Install both `modus-wc` and `modus-wc-angular` dependencies:\n\nEnsure that you specify the target version of Angular for the `modus-wc-angular` package (e.g., `ng18` for Angular 18).\n\n<b>\n  Lock the installed package versions to avoid unintended breakages on future\n  npm installs.\n</b>\n\n```bash\nnpm install @trimble-oss/moduswebcomponents @trimble-oss/moduswebcomponents-angular@<latest-version>-ng<target-version>\n```\n\n### 2. Set up the styling:\n\nYou will need to import our styling in your main JavaScript or CSS file:\n\n```js\nimport '@trimble-oss/moduswebcomponents/modus-wc-styles.css';\n```\n\n### 3. Import Modus Angular Web Components library into your Angular app's module:\n\n```ts\n// app.module.ts\nimport { ModusAngularComponentsModule } from '@trimble-oss/moduswebcomponents-angular';\n\n@NgModule({\n  ...\n  imports: [ComponentLibraryModule],\n  ...\n})\nexport class AppModule {}\n```\n\n### 4. Use Modus Angular Web Components while leveraging Angular template binding syntax:\n\n```ts\n// app.component.html\n<modus-wc-button label=\"Click Me\" />\n```\n\n## Angular with standalone components\n\nModus Angular Components have a peer dependency with Modus Web Components and require the\ninstallation of both packages.\n\n### 1. Install both `modus-wc` and `modus-wc-angular` dependencies:\n\nEnsure that you specify the target version of Angular for the `modus-wc-angular` package (e.g., `ng18` for Angular 18).\n\n<b>\n  Lock the installed package versions to avoid unintended breakages on future\n  npm installs.\n</b>\n\n```bash\nnpm install @trimble-oss/moduswebcomponents @trimble-oss/moduswebcomponents-angular@<latest-version>-ng<target-version>\n```\n\n### 2. Set up the styling:\n\nYou will need to import our styling in your main JavaScript or CSS file:\n\n```js\nimport '@trimble-oss/moduswebcomponents/modus-wc-styles.css';\n```\n\n### 3. Import your component library into your component.\n\nYou must distribute your components through a primary `NgModule` to use your components in a standalone component.\n\n```ts\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { ModusAngularComponentsModule } from '@trimble-oss/moduswebcomponents-angular';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [ModusAngularComponentsModule],\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {}\n```\n\n### 4. Use Modus Angular Web Components while leveraging Angular template binding syntax:\n\n```ts\n// app.component.html\n<modus-wc-button label=\"Click Me\" />\n```\n\n### Custom Elements Schema\n\nIn the `app.module.ts` file, you need to tell angular that you are using custom element schemas\nso that it does not throw errors when unknown element names are used in the markup.\n\nImport `CUSTOM_ELEMENTS_SCHEMA` and add it to your `@NgModule`'s schemas:\n\n```ts\nimport { CUSTOM_ELEMENTS_SCHEMA, NgModule } from '@angular/core';\n\n@NgModule({\n  ...\n  schemas: [CUSTOM_ELEMENTS_SCHEMA]\n  ...\n})\n```\n\n### Wrapping Components\n\nWhen using Modus Web Components directly, it is recommended to wrap it in corresponding Angular components within your application. This will abstract away from the library dependency, allowing more flexibility for you and your application in the future. Each part of the component is able to be abstracted, leaving you with an Angular-native component.\n\nNotice Angular allows `[]` and `()` markup syntax for the web component's inputs and outputs, respectively.\n\nWrapped Modus Button Example:\n\n```ts\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'button-component',\n  template: `\n    <modus-wc-button\n      [buttonStyle]=\"buttonStyle\"\n      [color]=\"color\"\n      [disabled]=\"disabled\"\n      [size]=\"size\"\n      (buttonClick)=\"onButtonClick.emit()\"\n    >\n      <ng-content></ng-content>\n    </modus-wc-button>\n  `,\n})\nexport class ButtonComponent {\n  @Input() buttonStyle: 'borderless' | 'fill' | 'outline' = 'fill';\n  @Input() color: 'danger' | 'default' | 'primary' | 'secondary' | 'warning' =\n    'default';\n  @Input() disabled: boolean;\n  @Input() size: 'small' | 'medium' | 'large' = 'medium';\n\n  @Output() onButtonClick = new EventEmitter();\n}\n```\n\n### Reactive Forms\n\nWorking with a web component's inputs/outputs works great but these components do not integrate with Angular's reactive forms quite as easily. Since web components do not know about Angular's form APIs, we must extend form-compatible components' behavior with simple directives. These directives are applied to the web component selectors, giving the components Angular form functionality.\n\nLet's take a look at a directive implementation for a Modus Select's form functionality.\n\n#### Wrapper\n\nYou'll notice the `modus-select` in the markup is taking extra inputs, such as `formControl` and `optionsDisplayProp`, these inputs are provided by the directive below. Here is what our wrapper looks like:\n\n```ts\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'select-component',\n  template: `\n    <modus-wc-select\n      #select\n      [disabled]=\"disabled\"\n      [errorText]=\"errorText\"\n      [formControl]=\"formControl\"\n      [helperText]=\"helperText\"\n      [label]=\"label\"\n      [options]=\"options\"\n      [optionsDisplayProp]=\"optionsDisplayProp\"\n      [required]=\"required\"\n      [selectValue]=\"value\"\n      [size]=\"size\"\n      [validText]=\"validText\"\n      (valueChange)=\"onSelectValueChange.emit(select.value)\"\n    >\n    </modus-wc-select>\n  `,\n})\nexport class SelectComponent {\n  @Input() disabled: boolean;\n  @Input() errorText: string;\n  @Input() formControl: FormControl;\n  @Input() helperText: string;\n  @Input() label: string;\n  @Input() options: unknown[] = [];\n  @Input() optionsDisplayProp: string;\n  @Input() required: boolean;\n  @Input() size: 'medium' | 'large' = 'medium';\n  @Input() validText: string;\n  @Input() value: unknown;\n\n  @Output() onSelectValueChange = new EventEmitter<unknown>();\n}\n```\n\n#### Directive\n\nMoving onto the directive, there are a few things to keep in mind.\n\n- The directive's selector is set to the web component's tag, not the wrapper's.\n- Implementing the `ControlValueAccessor` interface helps Angular understand when the form control has been updated or changed.\n  - When the value is set, `onChange()` notifies that the control has been updated.\n  - Calling `onTouched()` lets Angular know the component has been touched, which is needed for form validation.\n- The `get value()`, and `set value()` are used by Angular's form control.\n- Using the `@HostListener` decorator lets you listen to events from the web component, and execute appropriate logic.\n\nHere is what our directive looks like:\n\n```ts\nimport {\n  Directive,\n  forwardRef,\n  ElementRef,\n  HostListener,\n  Input,\n  OnInit,\n  Output,\n  EventEmitter,\n} from '@angular/core';\nimport {\n  ControlValueAccessor,\n  FormControl,\n  NG_VALUE_ACCESSOR,\n} from '@angular/forms';\n\n@Directive({\n  selector: 'modus-wc-select',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ModusSelectDirective),\n      multi: true,\n    },\n  ],\n})\nexport class ModusSelectDirective implements ControlValueAccessor, OnInit {\n  @Input() disabled: boolean;\n  @Input() errorText: string;\n  @Input() formControl: FormControl;\n  @Input() helperText: string;\n  @Input() label: string;\n  @Input() options: unknown[];\n  @Input() optionsDisplayProp: string;\n  @Input() required: boolean;\n  @Input() selectValue: unknown;\n  @Input() size: 'medium' | 'large';\n  @Input() validText: string;\n\n  @Output() valueChange = new EventEmitter<string>();\n\n  onChange: any = () => {};\n  onTouched: any = () => {};\n\n  private _value: string;\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    if (value !== this._value) {\n      this._value = value;\n      this.onChange(this._value);\n      this.onTouched();\n      this.elementRef.nativeElement.value = value;\n    }\n  }\n\n  constructor(private elementRef: ElementRef) {}\n\n  ngOnInit(): void {\n    const modusSelect = this.elementRef.nativeElement as HTMLModusSelectElement;\n    modusSelect.disabled = this.disabled;\n    modusSelect.errorText = this.errorText;\n    modusSelect.helperText = this.helperText;\n    modusSelect.label = this.label;\n    modusSelect.options = this.options;\n    modusSelect.optionsDisplayProp = this.optionsDisplayProp;\n    modusSelect.required = this.required;\n    modusSelect.size = this.size;\n    modusSelect.validText = this.validText;\n    modusSelect.value = this.selectValue;\n\n    if (!this.formControl) {\n      this.formControl = new FormControl(null);\n    }\n  }\n\n  @HostListener('valueChange', ['$event.detail'])\n  listenForValueChange(value: string): void {\n    this.value = value;\n  }\n\n  registerOnChange(fn: Function): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: Function): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  writeValue(value: string): void {\n    if (value) {\n      this.value = value;\n    }\n  }\n}\n```\n\nNow adding the Modus Select as a form control is as easy as:\n\n```ts\n<select-component\n  [formControl]=\"$any(form).controls['select1']\"\n  [label]=\"'Select Form Demo'\"\n  [options]=\"options\"\n  [optionsDisplayProp]=\"'display'\">\n</select-component>\n```\n",
  "examples": {}
}