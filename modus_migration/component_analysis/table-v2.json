{
  "component_name": "modus-wc-table",
  "version": "v2",
  "props": [
    {
      "name": "editable",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": boolean | ((row: Record<string, unknown>)"
    },
    {
      "name": "columns",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": ITableColumn[]"
    },
    {
      "name": "customClass",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": string"
    },
    {
      "name": "data",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": Record<string, unknown>[]"
    },
    {
      "name": "density",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": Density"
    },
    {
      "name": "hover",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": boolean"
    },
    {
      "name": "currentPage",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": "number"
    },
    {
      "name": "paginated",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": boolean"
    },
    {
      "name": "pageSizeOptions",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": "number[]"
    },
    {
      "name": "showPageSizeSelector",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": boolean"
    },
    {
      "name": "sortable",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": boolean"
    },
    {
      "name": "selectable",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": 'none' | 'single' | 'multi'"
    },
    {
      "name": "selectedRowIds",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": string[]"
    },
    {
      "name": "zebra",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": boolean"
    },
    {
      "name": "caption",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */",
      "type": ": string"
    }
  ],
  "events": [
    {
      "name": "cellEditStart",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */\n  @Prop() editable?: boolean | ((row: Record<string, unknown>) => boolean) =\n    false;\n\n  /** An array of column definitions. */\n  @Prop() columns!: ITableColumn[];\n\n  /** Custom CSS class to apply to the inner div. */\n  @Prop() customClass?: string = '';\n\n  /** An array of data objects. */\n  @Prop() data!: Record<string, unknown>[];\n\n  /** The density of the table, used to save space or increase readability. */\n  @Prop() density?: Density = 'comfortable';\n\n  /** Enable hover effect on table rows. */\n  @Prop() hover?: boolean = true;\n\n  /** The current page number in pagination (1-based index). */\n  @Prop() currentPage: number = 1;\n\n  /** Enable pagination for the table. */\n  @Prop() paginated?: boolean = false;\n\n  /** Available options for the number of rows per page. */\n  @Prop() pageSizeOptions: number[] = [5, 10, 15];\n\n  /** Show/hide the page size selector in pagination. */\n  @Prop() showPageSizeSelector?: boolean = true;\n\n  /** Enable sorting functionality for sortable columns. */\n  @Prop() sortable?: boolean = true;\n\n  /** Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows. */\n  @Prop() selectable?: 'none' | 'single' | 'multi' = 'none';\n\n  /** Array of selected row IDs. Used for controlled selection state. */\n  @Prop() selectedRowIds?: string[];\n\n  /** Zebra striped tables differentiate rows by styling them in an alternating fashion. */\n  @Prop() zebra?: boolean = false;\n\n  /** Accessibility caption for the table (visually hidden but available to screen readers). */\n  @Prop() caption?: string;\n\n  /** Currently editing cell coordinates */\n  @State() activeEditor?: { rowIndex: number; colId: string } | null = null;\n\n  /** Emits when cell editing starts. */"
    },
    {
      "name": "cellEditCommit",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */\n  @Prop() editable?: boolean | ((row: Record<string, unknown>) => boolean) =\n    false;\n\n  /** An array of column definitions. */\n  @Prop() columns!: ITableColumn[];\n\n  /** Custom CSS class to apply to the inner div. */\n  @Prop() customClass?: string = '';\n\n  /** An array of data objects. */\n  @Prop() data!: Record<string, unknown>[];\n\n  /** The density of the table, used to save space or increase readability. */\n  @Prop() density?: Density = 'comfortable';\n\n  /** Enable hover effect on table rows. */\n  @Prop() hover?: boolean = true;\n\n  /** The current page number in pagination (1-based index). */\n  @Prop() currentPage: number = 1;\n\n  /** Enable pagination for the table. */\n  @Prop() paginated?: boolean = false;\n\n  /** Available options for the number of rows per page. */\n  @Prop() pageSizeOptions: number[] = [5, 10, 15];\n\n  /** Show/hide the page size selector in pagination. */\n  @Prop() showPageSizeSelector?: boolean = true;\n\n  /** Enable sorting functionality for sortable columns. */\n  @Prop() sortable?: boolean = true;\n\n  /** Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows. */\n  @Prop() selectable?: 'none' | 'single' | 'multi' = 'none';\n\n  /** Array of selected row IDs. Used for controlled selection state. */\n  @Prop() selectedRowIds?: string[];\n\n  /** Zebra striped tables differentiate rows by styling them in an alternating fashion. */\n  @Prop() zebra?: boolean = false;\n\n  /** Accessibility caption for the table (visually hidden but available to screen readers). */\n  @Prop() caption?: string;\n\n  /** Currently editing cell coordinates */\n  @State() activeEditor?: { rowIndex: number; colId: string } | null = null;\n\n  /** Emits when cell editing starts. */"
    },
    {
      "name": "rowClick",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */\n  @Prop() editable?: boolean | ((row: Record<string, unknown>) => boolean) =\n    false;\n\n  /** An array of column definitions. */\n  @Prop() columns!: ITableColumn[];\n\n  /** Custom CSS class to apply to the inner div. */\n  @Prop() customClass?: string = '';\n\n  /** An array of data objects. */\n  @Prop() data!: Record<string, unknown>[];\n\n  /** The density of the table, used to save space or increase readability. */\n  @Prop() density?: Density = 'comfortable';\n\n  /** Enable hover effect on table rows. */\n  @Prop() hover?: boolean = true;\n\n  /** The current page number in pagination (1-based index). */\n  @Prop() currentPage: number = 1;\n\n  /** Enable pagination for the table. */\n  @Prop() paginated?: boolean = false;\n\n  /** Available options for the number of rows per page. */\n  @Prop() pageSizeOptions: number[] = [5, 10, 15];\n\n  /** Show/hide the page size selector in pagination. */\n  @Prop() showPageSizeSelector?: boolean = true;\n\n  /** Enable sorting functionality for sortable columns. */\n  @Prop() sortable?: boolean = true;\n\n  /** Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows. */\n  @Prop() selectable?: 'none' | 'single' | 'multi' = 'none';\n\n  /** Array of selected row IDs. Used for controlled selection state. */\n  @Prop() selectedRowIds?: string[];\n\n  /** Zebra striped tables differentiate rows by styling them in an alternating fashion. */\n  @Prop() zebra?: boolean = false;\n\n  /** Accessibility caption for the table (visually hidden but available to screen readers). */\n  @Prop() caption?: string;\n\n  /** Currently editing cell coordinates */\n  @State() activeEditor?: { rowIndex: number; colId: string } | null = null;\n\n  /** Emits when cell editing starts. */"
    },
    {
      "name": "sortChange",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */\n  @Prop() editable?: boolean | ((row: Record<string, unknown>) => boolean) =\n    false;\n\n  /** An array of column definitions. */\n  @Prop() columns!: ITableColumn[];\n\n  /** Custom CSS class to apply to the inner div. */\n  @Prop() customClass?: string = '';\n\n  /** An array of data objects. */\n  @Prop() data!: Record<string, unknown>[];\n\n  /** The density of the table, used to save space or increase readability. */\n  @Prop() density?: Density = 'comfortable';\n\n  /** Enable hover effect on table rows. */\n  @Prop() hover?: boolean = true;\n\n  /** The current page number in pagination (1-based index). */\n  @Prop() currentPage: number = 1;\n\n  /** Enable pagination for the table. */\n  @Prop() paginated?: boolean = false;\n\n  /** Available options for the number of rows per page. */\n  @Prop() pageSizeOptions: number[] = [5, 10, 15];\n\n  /** Show/hide the page size selector in pagination. */\n  @Prop() showPageSizeSelector?: boolean = true;\n\n  /** Enable sorting functionality for sortable columns. */\n  @Prop() sortable?: boolean = true;\n\n  /** Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows. */\n  @Prop() selectable?: 'none' | 'single' | 'multi' = 'none';\n\n  /** Array of selected row IDs. Used for controlled selection state. */\n  @Prop() selectedRowIds?: string[];\n\n  /** Zebra striped tables differentiate rows by styling them in an alternating fashion. */\n  @Prop() zebra?: boolean = false;\n\n  /** Accessibility caption for the table (visually hidden but available to screen readers). */\n  @Prop() caption?: string;\n\n  /** Currently editing cell coordinates */\n  @State() activeEditor?: { rowIndex: number; colId: string } | null = null;\n\n  /** Emits when cell editing starts. */"
    },
    {
      "name": "paginationChange",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */\n  @Prop() editable?: boolean | ((row: Record<string, unknown>) => boolean) =\n    false;\n\n  /** An array of column definitions. */\n  @Prop() columns!: ITableColumn[];\n\n  /** Custom CSS class to apply to the inner div. */\n  @Prop() customClass?: string = '';\n\n  /** An array of data objects. */\n  @Prop() data!: Record<string, unknown>[];\n\n  /** The density of the table, used to save space or increase readability. */\n  @Prop() density?: Density = 'comfortable';\n\n  /** Enable hover effect on table rows. */\n  @Prop() hover?: boolean = true;\n\n  /** The current page number in pagination (1-based index). */\n  @Prop() currentPage: number = 1;\n\n  /** Enable pagination for the table. */\n  @Prop() paginated?: boolean = false;\n\n  /** Available options for the number of rows per page. */\n  @Prop() pageSizeOptions: number[] = [5, 10, 15];\n\n  /** Show/hide the page size selector in pagination. */\n  @Prop() showPageSizeSelector?: boolean = true;\n\n  /** Enable sorting functionality for sortable columns. */\n  @Prop() sortable?: boolean = true;\n\n  /** Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows. */\n  @Prop() selectable?: 'none' | 'single' | 'multi' = 'none';\n\n  /** Array of selected row IDs. Used for controlled selection state. */\n  @Prop() selectedRowIds?: string[];\n\n  /** Zebra striped tables differentiate rows by styling them in an alternating fashion. */\n  @Prop() zebra?: boolean = false;\n\n  /** Accessibility caption for the table (visually hidden but available to screen readers). */\n  @Prop() caption?: string;\n\n  /** Currently editing cell coordinates */\n  @State() activeEditor?: { rowIndex: number; colId: string } | null = null;\n\n  /** Emits when cell editing starts. */"
    },
    {
      "name": "rowSelectionChange",
      "description": "/** Key to access data from row object */\n  accessor: string;\n  /** Custom cell renderer */\n  cellRenderer?: (value: unknown, row: unknown) => string | HTMLElement;\n  /** Class names for the column */\n  className?: string;\n  /** Header content - can be string or HTML */\n  header: string | HTMLElement;\n  /** Unique identifier for the column */\n  id: string;\n  /** Width style (e.g., '200px', '50%') */\n  width?: string;\n  /** Whether the column is sortable */\n  sortable?: boolean;\n  /** Built-in editor type to render when the cell is in edit mode. */\n  editor?: 'text' | 'number' | 'autocomplete' | 'date' | 'custom';\n  /** Extra props specific to the editor component. */\n  editorProps?: Record<string, unknown>;\n  /** Custom renderer invoked when editor === 'custom'. Must call onCommit with the new value. */\n  customEditorRenderer?: (\n    value: unknown,\n    onCommit: (val: unknown) => void,\n    row: Record<string, unknown>\n  ) => HTMLElement | string;\n\n  /**\n   * Alternative to built-in editors: raw HTML string. `${value}` placeholder will\n   * be replaced with the current cell value.\n   */\n  editorTemplate?: string;\n\n  /**\n   * Runs once after the editor element is added to the DOM. Gives full control\n   * for wiring events, populating data, etc.\n   */\n  editorSetup?: (\n    el: HTMLElement,\n    row: Record<string, unknown>,\n    commit: (newVal: unknown) => void\n  ) => void;\n}\n\nexport interface IPaginationChangeEventDetail {\n  currentPage: number;\n  pageSize: number;\n}\n\n@Component({\n  tag: 'modus-wc-table',\n  styleUrl: 'modus-wc-table.scss',\n  shadow: false,\n})\nexport class ModusWcTable {\n  private inheritedAttributes: Attributes = {};\n  private table: Table<Record<string, unknown>> | null = null;\n  private tanStackColumns: ColumnDef<Record<string, unknown>, unknown>[] = [];\n\n  /** Reference to the host element */\n  @Element() el!: HTMLElement;\n\n  /** Enable cell editing. Either a boolean (all rows) or a predicate per row. */\n  @Prop() editable?: boolean | ((row: Record<string, unknown>) => boolean) =\n    false;\n\n  /** An array of column definitions. */\n  @Prop() columns!: ITableColumn[];\n\n  /** Custom CSS class to apply to the inner div. */\n  @Prop() customClass?: string = '';\n\n  /** An array of data objects. */\n  @Prop() data!: Record<string, unknown>[];\n\n  /** The density of the table, used to save space or increase readability. */\n  @Prop() density?: Density = 'comfortable';\n\n  /** Enable hover effect on table rows. */\n  @Prop() hover?: boolean = true;\n\n  /** The current page number in pagination (1-based index). */\n  @Prop() currentPage: number = 1;\n\n  /** Enable pagination for the table. */\n  @Prop() paginated?: boolean = false;\n\n  /** Available options for the number of rows per page. */\n  @Prop() pageSizeOptions: number[] = [5, 10, 15];\n\n  /** Show/hide the page size selector in pagination. */\n  @Prop() showPageSizeSelector?: boolean = true;\n\n  /** Enable sorting functionality for sortable columns. */\n  @Prop() sortable?: boolean = true;\n\n  /** Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows. */\n  @Prop() selectable?: 'none' | 'single' | 'multi' = 'none';\n\n  /** Array of selected row IDs. Used for controlled selection state. */\n  @Prop() selectedRowIds?: string[];\n\n  /** Zebra striped tables differentiate rows by styling them in an alternating fashion. */\n  @Prop() zebra?: boolean = false;\n\n  /** Accessibility caption for the table (visually hidden but available to screen readers). */\n  @Prop() caption?: string;\n\n  /** Currently editing cell coordinates */\n  @State() activeEditor?: { rowIndex: number; colId: string } | null = null;\n\n  /** Emits when cell editing starts. */"
    }
  ],
  "slots": [],
  "default_values": {
    "editable": "> boolean) =\n    false",
    "columns": "= 'none',\n      pagination: this.internalPagination,\n      enableSorting: this.sortable,\n      manualPagination: !this.paginated,\n      manualSorting: false, // Let TanStack handle sorting internally\n      onSortingChange: this.handleSortingChange,\n      onPaginationChange: this.handlePaginationChange,\n      onRowSelectionChange: this.handleRowSelectionChange,\n      getRowId: (orig: Record<string, unknown>, idx) =>\n        orig && orig['id'] !== undefined && orig['id'] !== null\n          ? String(orig['id'] as string | number)\n          : String(idx),\n    })",
    "customClass": "''",
    "data": "= 'none',\n      pagination: this.internalPagination,\n      enableSorting: this.sortable,\n      manualPagination: !this.paginated,\n      manualSorting: false, // Let TanStack handle sorting internally\n      onSortingChange: this.handleSortingChange,\n      onPaginationChange: this.handlePaginationChange,\n      onRowSelectionChange: this.handleRowSelectionChange,\n      getRowId: (orig: Record<string, unknown>, idx) =>\n        orig && orig['id'] !== undefined && orig['id'] !== null\n          ? String(orig['id'] as string | number)\n          : String(idx),\n    })",
    "density": "'comfortable'",
    "hover": "true",
    "currentPage": "1",
    "paginated": "false",
    "pageSizeOptions": "[5, 10, 15]",
    "showPageSizeSelector": "true",
    "sortable": "true",
    "selectable": "'none'",
    "selectedRowIds": "> [id, true]) ?? []\n    )",
    "zebra": "false"
  },
  "documentation": "\n\n--- modus-wc-table.stories.ts ---\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { action } from '@storybook/addon-actions';\nimport { Meta, StoryObj } from '@storybook/web-components';\nimport { html } from 'lit';\nimport { ITableColumn } from './modus-wc-table';\nimport { IAutocompleteItem } from '../types';\nimport { Density } from '../types';\n\ninterface TableStoryArgs {\n  'custom-class'?: string;\n  'current-page'?: number;\n  'page-size-options'?: number[];\n  'selected-row-ids'?: string[];\n  'show-page-size-selector'?: boolean;\n  caption?: string;\n  columns?: ITableColumn[];\n  data?: Record<string, unknown>[];\n  density?: Density;\n  editable?: boolean;\n  hover?: boolean;\n  paginated?: boolean;\n  selectable?: 'none' | 'single' | 'multi';\n  sortable?: boolean;\n  zebra?: boolean;\n}\n\nconst meta: Meta<TableStoryArgs> = {\n  title: 'Components/Table',\n  component: 'modus-wc-table',\n\n  argTypes: {\n    columns: {\n      control: 'object',\n      description: 'An array of column definitions.',\n      table: {\n        type: {\n          detail: `\n            Interface: ITableColumn\n            Properties:\n            - accessor (string): Key to access data from row object\n            - cellRenderer? (function): Custom cell renderer (value, row) => string | HTMLElement\n            - className? (string): Class names for the column\n            - header (string | HTMLElement): Header content\n            - id (string): Unique identifier for the column\n            - width? (string): Width style (e.g., '200px', '50%')\n            - sortable? (boolean): Whether the column is sortable\n            - editor? ('text' | 'number' | 'autocomplete' | 'date' | 'custom'): Built-in editor type\n            - editorProps? (object): Extra props specific to the editor component\n            - customEditorRenderer? (function): Custom renderer for 'custom' editor\n            - editorTemplate? (string): Raw HTML string for editor, with \\`\\${value}\\` placeholder\n            - editorSetup? (function): Runs after the editor element is added to the DOM\n          `,\n        },\n      },\n    },\n    data: {\n      control: 'object',\n      description: 'An array of data objects.',\n      table: {\n        type: {\n          detail: `\n            Data should be an array of objects, where each object represents a row and each key matches a column accessor.\n\n            Example:\n            [\n              { id: '1', name: 'Alice', email: 'alice@example.com', role: 'Admin' },\n              { id: '2', name: 'Bob', email: 'bob@example.com', role: 'User' }\n            ]\n\n            - Each property in the object should correspond to a column's accessor value.\n            - The 'id' property is recommended for row identification and selection.\n          `,\n        },\n      },\n    },\n    density: {\n      control: {\n        type: 'select',\n      },\n      options: ['condensed', 'comfortable', 'relaxed'],\n      description:\n        'The density of the table, used to save space or increase readability.',\n    },\n    hover: {\n      control: 'boolean',\n      description: 'Enable hover effect on table rows.',\n      defaultValue: true,\n    },\n    sortable: {\n      control: 'boolean',\n      description: 'Enable sorting functionality for sortable columns.',\n      defaultValue: true,\n    },\n    paginated: {\n      control: 'boolean',\n      description: 'Enable pagination for the table.',\n      defaultValue: false,\n    },\n    'show-page-size-selector': {\n      control: 'boolean',\n      description: 'Show/hide the page size selector in pagination.',\n      defaultValue: true,\n    },\n    caption: {\n      control: 'text',\n      description:\n        'Accessibility caption for the table that is visually hidden but available to screen readers.',\n    },\n    'custom-class': {\n      control: 'text',\n      description: 'Custom CSS class to apply to the inner div.',\n    },\n    selectable: {\n      control: {\n        type: 'select',\n      },\n      options: ['none', 'single', 'multi'],\n      description:\n        \"Row selection mode: 'none' for no selection, 'single' for single row, 'multi' for multiple rows.\",\n      defaultValue: 'none',\n    },\n    zebra: {\n      control: 'boolean',\n      description:\n        'Zebra striped tables differentiate rows by styling them in an alternating fashion.',\n      defaultValue: false,\n    },\n    'current-page': {\n      control: 'number',\n      description: 'The current page number in pagination (1-based index).',\n      defaultValue: 1,\n    },\n    'page-size-options': {\n      control: 'object',\n      description: 'Available options for the number of rows per page.',\n      defaultValue: [5, 10, 15],\n    },\n    'selected-row-ids': {\n      control: 'object',\n      description:\n        'Array of selected row IDs. Used for controlled selection state.',\n      defaultValue: [],\n    },\n    editable: {\n      control: 'boolean',\n      description:\n        'Enable cell editing. Either a boolean (all rows) or a predicate per row.',\n      defaultValue: false,\n    },\n  },\n};\n\nexport default meta;\ntype Story = StoryObj<TableStoryArgs>;\n\n// Helper functions\nconst createDemoColumns = (): ITableColumn[] => [\n  {\n    id: 'id',\n    header: 'ID',\n    accessor: 'id',\n    width: '60px',\n  },\n  {\n    id: 'name',\n    header: 'Name',\n    accessor: 'name',\n    width: '100px',\n  },\n  {\n    id: 'email',\n    header: 'Email',\n    accessor: 'email',\n  },\n  {\n    id: 'role',\n    header: 'Role',\n    accessor: 'role',\n  },\n];\n\nconst createSortableColumns = (): ITableColumn[] => {\n  const columns = createDemoColumns();\n  return columns.map((col) => ({ ...col, sortable: true }));\n};\n\nconst createDemoData = (count = 5): Record<string, any>[] => {\n  const data: Record<string, any>[] = [];\n  for (let i = 1; i <= count; i++) {\n    data.push({\n      id: i.toString(),\n      name: `User ${i}`,\n      email: `user${i}@example.com`,\n      role: i % 2 === 0 ? 'Admin' : 'User',\n    });\n  }\n  return data;\n};\n\nexport const Default: Story = {\n  render: (args) => {\n    const columns = args.columns || createDemoColumns();\n    const data = args.data || createDemoData();\n    return html`\n      <script>\n            // Helper functions\n        const createDemoColumns = (): ITableColumn[] => [\n          {\n            id: 'id',\n            header: 'ID',\n            accessor: 'id',\n            width: '60px',\n          },\n          {\n            id: 'name',\n            header: 'Name',\n            accessor: 'name',\n            width: '100px',\n          },\n          {\n            id: 'email',\n            header: 'Email',\n            accessor: 'email',\n          },\n          {\n            id: 'role',\n            header: 'Role',\n            accessor: 'role',\n          },\n        ];\n\n        const createDemoData = (count = 5): Record<string, any>[] => {\n          const data: Record<string, any>[] = [];\n          for (let i = 1; i <= count; i++) {\n            data.push({\n              id: i.toString(),\n              name: \\`User \\${i}\\`,\n              email: \\`user\\${i}@example.com\\`,\n              role: i % 2 === 0 ? 'Admin' : 'User',\n            });\n          }\n          return data;\n        };\n      </script>\n      <modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        .caption=${args.caption}\n        @rowClick=${action('rowClick')}\n        @sortChange=${action('sortChange')}\n        @paginationChange=${action('paginationChange')}\n        @rowSelectionChange=${action('rowSelectionChange')}\n        @cellEditStart=${action('cellEditStart')}\n        @cellEditCommit=${action('cellEditCommit')}\n      ></modus-wc-table>\n    `;\n  },\n  args: {\n    density: 'comfortable',\n    hover: false,\n    sortable: true,\n    paginated: false,\n    'show-page-size-selector': true,\n    'custom-class': '',\n    selectable: 'none',\n    zebra: false,\n    'current-page': 1,\n    'page-size-options': [5, 10, 15],\n    'selected-row-ids': [],\n    editable: false,\n  },\n};\n\nexport const Hover: Story = {\n  render: (args) => {\n    const columns = args.columns || createDemoColumns();\n    const data = args.data || createDemoData();\n    return html`\n      <script>\n        // Helper functions\n        const createDemoColumns = (): ITableColumn[] => [\n          {\n            id: 'id',\n            header: 'ID',\n            accessor: 'id',\n            width: '60px',\n          },\n          {\n            id: 'name',\n            header: 'Name',\n            accessor: 'name',\n            width: '100px',\n          },\n          {\n            id: 'email',\n            header: 'Email',\n            accessor: 'email',\n          },\n          {\n            id: 'role',\n            header: 'Role',\n            accessor: 'role',\n          },\n        ];\n\n        const createDemoData = (count = 5): Record<string, any>[] => {\n          const data: Record<string, any>[] = [];\n          for (let i = 1; i <= count; i++) {\n            data.push({\n              id: i.toString(),\n              name: \\`User \\${i}\\`,\n              email: \\`user\\${i}@example.com\\`,\n              role: i % 2 === 0 ? 'Admin' : 'User',\n            });\n          }\n          return data;\n        };\n      </script>\n      <modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @rowClick=${action('rowClick')}\n      ></modus-wc-table>\n    `;\n  },\n  args: {\n    density: 'comfortable',\n    hover: true,\n  },\n};\n\nexport const Sorting: Story = {\n  render: (args) => {\n    const columns = args.columns || createSortableColumns();\n    const data = args.data || createDemoData();\n    return html`\n      <script>\n        // Helper functions\n        const createDemoColumns = (): ITableColumn[] => [\n          {\n            id: 'id',\n            header: 'ID',\n            accessor: 'id',\n            width: '60px',\n          },\n          {\n            id: 'name',\n            header: 'Name',\n            accessor: 'name',\n            width: '100px',\n          },\n          {\n            id: 'email',\n            header: 'Email',\n            accessor: 'email',\n          },\n          {\n            id: 'role',\n            header: 'Role',\n            accessor: 'role',\n          },\n        ];\n\n        const createSortableColumns = (): ITableColumn[] => {\n          const columns = createDemoColumns();\n          return columns.map((col) => ({ ...col, sortable: true }));\n        };\n\n        const createDemoData = (count = 5): Record<string, any>[] => {\n          const data: Record<string, any>[] = [];\n          for (let i = 1; i <= count; i++) {\n            data.push({\n              id: i.toString(),\n              name: \\`User \\${i}\\`,\n              email: \\`user\\${i}@example.com\\`,\n              role: i % 2 === 0 ? 'Admin' : 'User',\n            });\n          }\n          return data;\n        };\n      </script>\n      <modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @sortChange=${action('sortChange')}\n      ></modus-wc-table>\n    `;\n  },\n  args: {\n    density: 'comfortable',\n    sortable: true,\n  },\n};\n\nexport const Pagination: Story = {\n  render: (args) => {\n    const columns = args.columns || createDemoColumns();\n    const data = args.data || createDemoData(15);\n    return html`\n      <script>\n            // Helper functions\n            const createDemoColumns = (): ITableColumn[] => [\n              {\n                id: 'id',\n                header: 'ID',\n                accessor: 'id',\n                width: '60px',\n              },\n              {\n                id: 'name',\n                header: 'Name',\n                accessor: 'name',\n                width: '100px',\n              },\n              {\n                id: 'email',\n                header: 'Email',\n                accessor: 'email',\n              },\n              {\n                id: 'role',\n                header: 'Role',\n                accessor: 'role',\n              },\n            ];\n\n          const createDemoData = (count = 5): Record<string, any>[] => {\n          const data: Record<string, any>[] = [];\n          for (let i = 1; i <= count; i++) {\n            data.push({\n              id: i.toString(),\n              name: \\`User \\${i}\\`,\n              email: \\`user\\${i}@example.com\\`,\n              role: i % 2 === 0 ? 'Admin' : 'User',\n            });\n          }\n          return data;\n        };\n        const columns = args.columns || createDemoColumns();\n        const data = args.data || createDemoData(15);\n      </script>\n      <modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @paginationChange=${action('paginationChange')}\n      ></modus-wc-table>\n    `;\n  },\n  args: {\n    density: 'comfortable',\n    paginated: true,\n    'show-page-size-selector': true,\n  },\n};\n\nexport const CheckBoxRowSelection: Story = {\n  render: (args) => {\n    const columns = args.columns || createDemoColumns();\n    const data = args.data || createDemoData();\n    return html`\n      <script>\n            // Helper functions\n            const createDemoColumns = (): ITableColumn[] => [\n              {\n                id: 'id',\n                header: 'ID',\n                accessor: 'id',\n                width: '60px',\n              },\n              {\n                id: 'name',\n                header: 'Name',\n                accessor: 'name',\n                width: '100px',\n              },\n              {\n                id: 'email',\n                header: 'Email',\n                accessor: 'email',\n              },\n              {\n                id: 'role',\n                header: 'Role',\n                accessor: 'role',\n              },\n            ];\n\n            const createDemoData = (count = 5): Record<string, any>[] => {\n              const data: Record<string, any>[] = [];\n              for (let i = 1; i <= count; i++) {\n                data.push({\n                  id: i.toString(),\n                  name: \\`User \\${i}\\`,\n                  email: \\`user\\${i}@example.com\\`,\n                  role: i % 2 === 0 ? 'Admin' : 'User',\n                });\n              }\n              return data;\n            };\n        const columns = args.columns || createDemoColumns();\n        const data = args.data || createDemoData(15);\n      </script>\n      <modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @rowSelectionChange=${action('rowSelectionChange')}\n      ></modus-wc-table>\n    `;\n  },\n  args: {\n    density: 'comfortable',\n    selectable: 'multi',\n  },\n};\n\nexport const InlineEditing: Story = {\n  render: (args) => {\n    const columns: ITableColumn[] = [\n      {\n        id: 'id',\n        header: 'ID',\n        accessor: 'id',\n        width: '20px',\n      },\n      {\n        id: 'name',\n        header: 'Name',\n        accessor: 'name',\n        editor: 'text',\n      },\n      {\n        id: 'status',\n        header: 'Status',\n        accessor: 'status',\n        editor: 'custom',\n        customEditorRenderer: (value, onCommit) => {\n          const container = document.createElement('div');\n          container.style.width = '100%';\n\n          const autocomplete = document.createElement('modus-wc-autocomplete');\n          autocomplete.items = [\n            { label: 'Active', value: 'Active', visibleInMenu: true },\n            { label: 'Inactive', value: 'Inactive', visibleInMenu: true },\n            { label: 'Pending', value: 'Pending', visibleInMenu: true },\n          ];\n          autocomplete.value = value as string;\n          autocomplete.style.width = '100%';\n\n          const handleItemSelect = (e: CustomEvent<IAutocompleteItem>) => {\n            onCommit(e.detail.value);\n          };\n\n          autocomplete.addEventListener(\n            'itemSelect',\n            handleItemSelect as EventListener\n          );\n          container.appendChild(autocomplete);\n\n          setTimeout(() => {\n            const input = autocomplete.querySelector('input');\n            input?.focus();\n          }, 0);\n\n          return container;\n        },\n        cellRenderer: (value) => {\n          const statusColors = {\n            Active: 'green',\n            Inactive: 'gray',\n            Pending: 'blue',\n          };\n          const color = statusColors[value as string] || 'black';\n          const span = document.createElement('span');\n          span.textContent = value as string;\n          span.style.color = color;\n          span.style.fontWeight = 'bold';\n          return span;\n        },\n      },\n    ];\n\n    const data = [\n      { id: '1', name: 'John Doe', status: 'Active' },\n      { id: '2', name: 'Jane Smith', status: 'Inactive' },\n      { id: '3', name: 'Bob Johnson', status: 'Pending' },\n    ];\n\n    return html`\n      <script>\n                // Helper functions\n                const createDemoColumns = (): ITableColumn[] => [\n                  {\n                    id: 'id',\n                    header: 'ID',\n                    accessor: 'id',\n                    width: '60px',\n                  },\n                  {\n                    id: 'name',\n                    header: 'Name',\n                    accessor: 'name',\n                    width: '100px',\n                  },\n                  {\n                    id: 'email',\n                    header: 'Email',\n                    accessor: 'email',\n                  },\n                  {\n                    id: 'role',\n                    header: 'Role',\n                    accessor: 'role',\n                  },\n                ];\n\n                const createDemoData = (count = 5): Record<string, any>[] => {\n                  const data: Record<string, any>[] = [];\n                  for (let i = 1; i <= count; i++) {\n                    data.push({\n                      id: i.toString(),\n                      name: \\`User \\${i}\\`,\n                      email: \\`user\\${i}@example.com\\`,\n                      role: i % 2 === 0 ? 'Admin' : 'User',\n                    });\n                  }\n                  return data;\n                };\n                    const columns: ITableColumn[] = [\n          {\n            id: 'id',\n            header: 'ID',\n            accessor: 'id',\n            width: '20px',\n          },\n          {\n            id: 'name',\n            header: 'Name',\n            accessor: 'name',\n            editor: 'text',\n          },\n          {\n            id: 'status',\n            header: 'Status',\n            accessor: 'status',\n            editor: 'custom',\n            customEditorRenderer: (value, onCommit) => {\n              const container = document.createElement('div');\n              container.style.width = '100%';\n\n              const autocomplete = document.createElement('modus-wc-autocomplete');\n              autocomplete.items = [\n                { label: 'Active', value: 'Active', visibleInMenu: true },\n                { label: 'Inactive', value: 'Inactive', visibleInMenu: true },\n                { label: 'Pending', value: 'Pending', visibleInMenu: true },\n              ];\n              autocomplete.value = value as string;\n              autocomplete.style.width = '100%';\n\n              const handleItemSelect = (e: CustomEvent<IAutocompleteItem>) => {\n                onCommit(e.detail.value);\n              };\n\n              autocomplete.addEventListener(\n                'itemSelect',\n                handleItemSelect as EventListener\n              );\n              container.appendChild(autocomplete);\n\n              setTimeout(() => {\n                const input = autocomplete.querySelector('input');\n                input?.focus();\n              }, 0);\n\n              return container;\n            },\n            cellRenderer: (value) => {\n              const statusColors = {\n                Active: 'green',\n                Inactive: 'gray',\n                Pending: 'blue',\n              };\n              const color = statusColors[value as string] || 'black';\n              const span = document.createElement('span');\n              span.textContent = value as string;\n              span.style.color = color;\n              span.style.fontWeight = 'bold';\n              return span;\n            },\n          },\n        ];\n\n        const data = [\n          { id: '1', name: 'John Doe', status: 'Active' },\n          { id: '2', name: 'Jane Smith', status: 'Inactive' },\n          { id: '3', name: 'Bob Johnson', status: 'Pending' },\n        ];\n      </script>\n      <modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${true}\n        @cellEditStart=${action('cellEditStart')}\n        @cellEditCommit=${action('cellEditCommit')}\n      ></modus-wc-table>\n    `;\n  },\n  args: {\n    density: 'comfortable',\n    hover: true,\n    sortable: true,\n    paginated: false,\n    'show-page-size-selector': true,\n    'custom-class': '',\n    selectable: 'none',\n    zebra: false,\n    'current-page': 1,\n    'page-size-options': [5, 10, 15],\n    'selected-row-ids': [],\n  },\n};\n",
  "storybook": {
    "examples": [
      "<modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        .caption=${args.caption}\n        @rowClick=${action('rowClick')}\n        @sortChange=${action('sortChange')}\n        @paginationChange=${action('paginationChange')}\n        @rowSelectionChange=${action('rowSelectionChange')}\n        @cellEditStart=${action('cellEditStart')}\n        @cellEditCommit=${action('cellEditCommit')}\n      ></modus-wc-table>",
      "<modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @rowClick=${action('rowClick')}\n      ></modus-wc-table>",
      "<modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @sortChange=${action('sortChange')}\n      ></modus-wc-table>",
      "<modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @paginationChange=${action('paginationChange')}\n      ></modus-wc-table>",
      "<modus-wc-table\n        .columns=${columns}\n        .data=${data}\n        .density=${args.density}\n        .hover=${args.hover}\n        .sortable=${args.sortable}\n        .paginated=${args.paginated}\n        .showPageSizeSelector=${args['show-page-size-selector']}\n        .customClass=${args['custom-class']}\n        .selectable=${args.selectable}\n        .zebra=${args.zebra}\n        .currentPage=${args['current-page']}\n        .pageSizeOptions=${args['page-size-options']}\n        .selectedRowIds=${args['selected-row-ids']}\n        .editable=${args.editable}\n        @rowSelectionChange=${action('rowSelectionChange')}\n      ></modus-wc-table>"
    ],
    "variants": [],
    "prop_usage": {}
  },
  "tag_name": "modus-wc-table"
}