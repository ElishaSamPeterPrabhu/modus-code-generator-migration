{
  "component_name": "modus-wc-autocomplete",
  "version": "v2",
  "props": [],
  "events": [],
  "slots": [],
  "default_values": {},
  "documentation": "\n\n--- modus-wc-autocomplete.stories.ts ---\n\nimport { withActions } from '@storybook/addon-actions/decorator';\nimport { Meta, StoryObj } from '@storybook/web-components';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { IAutocompleteItem, IAutocompleteNoResults } from '../types';\nimport { ModusSize } from '../types';\n\n// Updated items array includes an optional \"focused\" property.\nconst items: IAutocompleteItem[] = [\n  {\n    label: 'Apple',\n    value: 'apple',\n    visibleInMenu: true,\n    focused: false,\n    disabled: false,\n    checkbox: false,\n  },\n  {\n    label: 'Banana',\n    value: 'banana',\n    visibleInMenu: true,\n    focused: false,\n    disabled: false,\n    checkbox: false,\n  },\n  {\n    label: 'Blueberry',\n    value: 'blueberry',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Cherry',\n    value: 'cherry',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Grape',\n    value: 'grape',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Lemon',\n    value: 'lemon',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Orange',\n    value: 'orange',\n    visibleInMenu: true,\n    focused: false,\n    disabled: false,\n    checkbox: false,\n  },\n  {\n    label: 'Peach',\n    value: 'peach',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Pear',\n    value: 'pear',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Strawberry',\n    value: 'strawberry',\n    visibleInMenu: true,\n    focused: false,\n    disabled: false,\n    checkbox: false,\n  },\n  {\n    label: 'Watermelon',\n    value: 'watermelon',\n    visibleInMenu: true,\n    focused: false,\n    disabled: false,\n    checkbox: false,\n  },\n  {\n    label: 'Pineapple',\n    value: 'pineapple',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Kiwi',\n    value: 'kiwi',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Mango',\n    value: 'mango',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Papaya',\n    value: 'papaya',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Plum',\n    value: 'plum',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Raspberry',\n    value: 'raspberry',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n  {\n    label: 'Tangerine',\n    value: 'tangerine',\n    visibleInMenu: true,\n    focused: false,\n    checkbox: false,\n  },\n];\n\ninterface AutocompleteArgs {\n  visibleItems: IAutocompleteItem[];\n  bordered?: boolean;\n  'custom-class'?: string;\n  'debounce-ms'?: number;\n  disabled?: boolean;\n  'include-clear'?: boolean;\n  'include-search'?: boolean;\n  'input-id'?: string;\n  'input-tab-index'?: number;\n  items: IAutocompleteItem[];\n  initialNavigation?: boolean;\n  label?: string;\n  'leave-menu-open'?: boolean;\n  'max-chips'?: number;\n  'min-chars': number;\n  'min-input-width'?: number;\n  'multi-select'?: boolean;\n  name?: string;\n  'no-results': IAutocompleteNoResults;\n  placeholder?: string;\n  'read-only'?: boolean;\n  required?: boolean;\n  'show-menu-on-focus'?: boolean;\n  'show-spinner'?: boolean;\n  size?: ModusSize;\n  value: string;\n  'custom-blur'?: (event: FocusEvent) => void;\n  'custom-input-change'?: (value: string) => void;\n  'custom-item-select'?: (item: IAutocompleteItem) => void;\n  'custom-key-down'?: (event: KeyboardEvent) => void;\n}\n\nconst meta: Meta<AutocompleteArgs> = {\n  title: 'Components/Forms/Autocomplete',\n  component: 'modus-wc-autocomplete',\n  args: {\n    bordered: true,\n    'debounce-ms': 300,\n    disabled: false,\n    'include-clear': false,\n    'include-search': false,\n    items: items,\n    label: 'Label',\n    'leave-menu-open': false,\n    'max-chips': 4,\n    'min-chars': 0,\n    'min-input-width': 15,\n    'multi-select': false,\n    'show-menu-on-focus': false,\n    'show-spinner': false,\n    'no-results': {\n      ariaLabel: 'No results found',\n      label: 'No results found',\n      subLabel: 'Check spelling or try a different keyword',\n    },\n    size: 'md',\n    value: '',\n  },\n  argTypes: {\n    items: {\n      description: 'Array of items for the autocomplete component',\n      table: {\n        type: {\n          detail: `\n            Interface: IAutocompleteItem\n            Properties:\n            - label (string): The display text shown for the autocomplete item\n            - selected (boolean, optional): Whether the item is currently selected\n            - focused (boolean, optional): Whether the item is focused\n            - value (string): The unique value identifier for the item\n            - visibleInMenu (boolean): Whether the item should be shown in the dropdown menu\n          `,\n        },\n      },\n    },\n    'max-chips': {\n      control: { type: 'number', min: 1, max: 10 },\n      description:\n        'Maximum number of chips to display before showing \"+N more\" button',\n    },\n    'min-input-width': {\n      control: { type: 'number', min: 10, max: 300 },\n      description:\n        'Minimum width for the text input in pixels. When chips would make input smaller, container height increases instead. Default: 20px.',\n    },\n    size: {\n      control: { type: 'select' },\n      options: ['sm', 'md', 'lg'],\n    },\n    'custom-blur': {\n      description:\n        'Custom blur handler function that overrides default blur behavior',\n      table: {\n        type: { summary: '(event: FocusEvent) => void' },\n        category: 'Custom Handlers',\n      },\n    },\n    'custom-input-change': {\n      description:\n        'Custom input change handler function that overrides default input change behavior',\n      table: {\n        type: { summary: '(value: string) => void' },\n        category: 'Custom Handlers',\n      },\n    },\n    'custom-item-select': {\n      description:\n        'Custom item select handler function that overrides default item selection behavior',\n      table: {\n        type: { summary: '(item: IAutocompleteItem) => void' },\n        category: 'Custom Handlers',\n      },\n    },\n    'custom-key-down': {\n      description:\n        'Custom keydown handler function that overrides default keyboard navigation',\n      table: {\n        type: { summary: '(event: KeyboardEvent) => void' },\n        category: 'Custom Handlers',\n      },\n    },\n  },\n  decorators: [withActions],\n  parameters: {\n    actions: {\n      handles: [\n        'chipRemove',\n        'chipsExpansionChange',\n        'inputBlur',\n        'inputChange',\n        'inputFocus',\n        'itemSelect',\n      ],\n    },\n  },\n};\n\nexport default meta;\n\ntype Story = StoryObj<AutocompleteArgs>;\n\nconst Template: Story = {\n  render: (args) => {\n    // prettier-ignore\n    return html`\n<style>\n  div[id^='story--components-forms-autocomplete--default'] {\n    height: 400px;\n  }\n</style>\n<modus-wc-autocomplete\n  aria-label=\"Fruit autocomplete\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  ?include-clear=${args['include-clear']}\n  ?include-search=${args['include-search']}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  .items=${args.items}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  min-chars=${args['min-chars']}\n  min-input-width=${ifDefined(args['min-input-width'])}\n  ?multi-select=${false}\n  name=${ifDefined(args.name)}\n  .noResults=${args['no-results']}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  ?show-spinner=${args['show-spinner']}\n  size=${ifDefined(args.size)}\n  value=${args.value}\n></modus-wc-autocomplete>\n    `;\n  },\n};\n\nexport const Default: Story = {\n  ...Template,\n};\n\nexport const WithCustomIconSlot: Story = {\n  // prettier-ignore\n  render: (args) => html`\n<style>\n  div[id^='story--components-forms-autocomplete--with-custom-icon-slot'] {\n    height: 400px;\n  }\n</style>\n<modus-wc-autocomplete\n  aria-label=\"Autocomplete with custom icon\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  ?include-clear=${args['include-clear']}\n  ?include-search=${args['include-search']}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  .items=${args.items}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  min-chars=${args['min-chars']}\n  min-input-width=${ifDefined(args['min-input-width'])}\n  ?multi-select=${false}\n  name=${ifDefined(args.name)}\n  .noResults=${args['no-results']}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  ?show-spinner=${args['show-spinner']}\n  size=${ifDefined(args.size)}\n  value=${args.value}\n>\n  <modus-wc-icon slot=\"custom-icon\" name=\"heart\" size=\"sm\"></modus-wc-icon>\n</modus-wc-autocomplete>\n  `,\n  args: {\n    placeholder: 'Search fruits...',\n  },\n};\n\nexport const WithTooltips: Story = {\n  name: 'With Tooltips',\n  parameters: {\n    docs: {\n      description: {\n        story:\n          'This example demonstrates menu items with tooltips. Hover over the items to see the tooltips.',\n      },\n      source: {\n        code: `\nconst tooltipItems = [\n  {\n    label: 'Apple',\n    value: 'apple',\n    tooltipContent: 'A crisp and sweet fruit',\n    tooltipPosition: 'top',\n    visibleInMenu: true,\n    focused: false,\n  },\n  {\n    label: 'Banana',\n    value: 'banana',\n    tooltipContent: 'A tropical yellow fruit',\n    tooltipPosition: 'right',\n    visibleInMenu: true,\n    focused: false,\n  },\n  {\n    label: 'Cherry',\n    value: 'cherry',\n    tooltipContent: 'Small red stone fruit',\n    tooltipPosition: 'bottom',\n    visibleInMenu: true,\n    focused: false,\n  },\n  {\n    label: 'Grape',\n    value: 'grape',\n    tooltipContent: 'Small juicy fruit that grows in clusters',\n    tooltipPosition: 'left',\n    visibleInMenu: true,\n    focused: false,\n  },\n  {\n    label: 'Orange',\n    value: 'orange',\n    tooltipContent: 'Citrus fruit with a bright color',\n    tooltipPosition: 'top',\n    visibleInMenu: true,\n    focused: false,\n  },\n];\n<modus-wc-autocomplete\n  aria-label=\"Fruits with tooltips\"\n  leave-menu-open=\"true\"\n  placeholder=\"Search fruits\"\n  .items={tooltipItems}\n  min-chars=\"0\"\n></modus-wc-autocomplete>\n`,\n      },\n    },\n  },\n  render: () => {\n    const tooltipItems: IAutocompleteItem[] = [\n      {\n        label: 'Apple',\n        value: 'apple',\n        tooltipContent: 'A crisp and sweet fruit',\n        tooltipPosition: 'top',\n        visibleInMenu: true,\n        focused: false,\n      },\n      {\n        label: 'Banana',\n        value: 'banana',\n        tooltipContent: 'A tropical yellow fruit',\n        tooltipPosition: 'right',\n        visibleInMenu: true,\n        focused: false,\n      },\n      {\n        label: 'Cherry',\n        value: 'cherry',\n        tooltipContent: 'Small red stone fruit',\n        tooltipPosition: 'bottom',\n        visibleInMenu: true,\n        focused: false,\n      },\n      {\n        label: 'Grape',\n        value: 'grape',\n        tooltipContent: 'Small juicy fruit that grows in clusters',\n        tooltipPosition: 'left',\n        visibleInMenu: true,\n        focused: false,\n      },\n      {\n        label: 'Orange',\n        value: 'orange',\n        tooltipContent: 'Citrus fruit with a bright color',\n        tooltipPosition: 'top',\n        visibleInMenu: true,\n        focused: false,\n      },\n    ];\n\n    return html`\n      <style>\n        div[id^='story--components-forms-autocomplete--with-tooltips'] {\n          height: 400px;\n        }\n      </style>\n      <div style=\"width: 300px;\">\n        <modus-wc-autocomplete\n          aria-label=\"Fruits with tooltips\"\n          leave-menu-open=\"true\"\n          placeholder=\"Search fruits\"\n          .items=${tooltipItems}\n          min-chars=\"0\"\n        ></modus-wc-autocomplete>\n      </div>\n    `;\n  },\n};\n\nexport const MultiSelect: Story = {\n  render: (args) => {\n    // Ensure args.items is initialized\n    if (!args.items) {\n      args.items = [...items];\n    }\n    // If multi-select, set selected state for some items\n    args.items = args.items.map((item) => {\n      if (item.value === 'apple' || item.value === 'banana') {\n        return { ...item, selected: true };\n      }\n      return item;\n    });\n    // prettier-ignore\n    return html`\n<script>\n  // Initialize args.items if empty\n  if (!args.items || args.items.length === 0) {\n    args.items = [...items];\n  }\n  // If multi-select, set selected state for some items\n  args.items = items.map((item) => {\n    if (item.value === 'apple' || item.value === 'banana') {\n      return { ...item, selected: true };\n    }\n    return item;\n  });\n</script>\n<style>\ndiv[id^='story--components-forms-autocomplete--multi-select'] {\n    height: 400px;\n  }\n  .modus-wc-autocomplete-multi-select {\n    width: 480px !important;\n  }\n</style>\n<modus-wc-autocomplete\n  aria-label=\"Fruit autocomplete\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  ?include-clear=${args['include-clear']}\n  ?include-search=${args['include-search']}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  .items=${args.items}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  max-chips=${args['max-chips'] ?? 4}\n  min-chars=${args['min-chars']}\n  min-input-width=${ifDefined(args['min-input-width'])}\n  ?multi-select=${true}\n  name=${ifDefined(args.name)}\n  .noResults=${args['no-results']}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  size=${ifDefined(args.size)}\n  value=${args.value}\n></modus-wc-autocomplete>\n    `;\n  },\n};\n\nexport const WithSpinner: Story = {\n  render: (args) => {\n    let debounceTimer: number;\n\n    const handleInputChange = (e: CustomEvent<Event>) => {\n      if (!e.detail?.target) return;\n\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      ) as Element & {\n        items: IAutocompleteItem[];\n        showSpinner: boolean;\n        value: string;\n      };\n\n      if (autocomplete) {\n        const input = e.detail.target as HTMLInputElement;\n        const searchText = input.value.toLowerCase();\n\n        // Clear previous timeout to avoid multiple API calls\n        if (debounceTimer) {\n          window.clearTimeout(debounceTimer);\n        }\n\n        // Show spinner immediately and update input value\n        autocomplete.showSpinner = true;\n\n        // Simulate an API call with a 2-second delay\n        debounceTimer = window.setTimeout(() => {\n          // Filter the master list of items to get the new results\n          const filteredItems = items.filter((item) =>\n            item.label.toLowerCase().includes(searchText)\n          );\n\n          // Update the component with the new filtered list and hide the spinner\n          autocomplete.items = filteredItems;\n          autocomplete.showSpinner = false;\n        }, 2000);\n      }\n    };\n    // prettier-ignore\n    return html`\n<script>\n        let debounceTimer: number;\n\n  const handleInputChange = (e: CustomEvent<Event>) => {\n    if (!e.detail?.target) return;\n\n    const autocomplete = (e.target as HTMLInputElement).closest(\n      'modus-wc-autocomplete'\n    ) as Element & {\n      items: IAutocompleteItem[];\n      showSpinner: boolean;\n      value: string;\n    };\n\n    if (autocomplete) {\n      const input = e.detail.target as HTMLInputElement;\n      const searchText = input.value.toLowerCase();\n\n      // Clear previous timeout to avoid multiple API calls\n      if (debounceTimer) {\n        window.clearTimeout(debounceTimer);\n      }\n\n      // Show spinner immediately and update input value\n      autocomplete.showSpinner = true;\n\n      // Simulate an API call with a 2-second delay\n      debounceTimer = window.setTimeout(() => {\n        // Filter the master list of items to get the new results\n        const filteredItems = items.filter((item) =>\n          item.label.toLowerCase().includes(searchText)\n        );\n\n        // Update the component with the new filtered list and hide the spinner\n        autocomplete.items = filteredItems;\n        autocomplete.showSpinner = false;\n      }, 2000);\n    }\n  };\n</script>\n<style>\n  div[id^='story--components-forms-autocomplete--with-spinner'] {\n    height: 400px;\n  }\n</style>\n<modus-wc-autocomplete\n  aria-label=\"Fruit autocomplete with spinner\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  .items=${args.items}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  min-chars=${args['min-chars']}\n  ?multi-select=${false}\n  name=${ifDefined(args.name)}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  ?show-spinner=${args['show-spinner']}\n  size=${ifDefined(args.size)}\n  value=${args.value}\n  @inputChange=${handleInputChange}\n></modus-wc-autocomplete>\n    `;\n  },\n};\n\nexport const CustomMenuItems: Story = {\n  render: (args) => {\n    const originalNoResults = args['no-results'];\n    if (args['leave-menu-open'] == true) {\n      args['no-results'] = {\n        ariaLabel: '',\n        label: '',\n        subLabel: '',\n      };\n    }\n\n    const getVisibleItems = (autocomplete: Element): HTMLElement[] => {\n      const menuItems = autocomplete.querySelectorAll(\n        'modus-wc-menu-item:not([disabled])'\n      );\n      return Array.from(menuItems).filter(\n        (item: Element): item is HTMLElement => {\n          const style = window.getComputedStyle(item);\n          return style.display !== 'none' && !item.classList.contains('hidden');\n        }\n      );\n    };\n\n    const handleCustomKeyDown = (e: KeyboardEvent) => {\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      ) as Element & {\n        openMenu: () => Promise<void>;\n        closeMenu: () => Promise<void>;\n        readOnly?: boolean;\n        disabled?: boolean;\n      };\n      if (!autocomplete) return;\n\n      // Don't process keyboard events when disabled or readOnly\n      if (autocomplete.disabled || autocomplete.readOnly) return;\n\n      const visibleItems = getVisibleItems(autocomplete);\n\n      // Get all button elements within visible menu items\n      const buttons = visibleItems\n        .map((item) => item.querySelector('button'))\n        .filter(Boolean) as HTMLButtonElement[];\n      const currentFocusedButton = document.activeElement as HTMLButtonElement;\n      const currentIndex = buttons.indexOf(currentFocusedButton);\n\n      switch (e.key) {\n        case 'ArrowDown': {\n          e.preventDefault();\n          // Open menu when arrow key is pressed\n          void autocomplete.openMenu();\n\n          let nextIndex = currentIndex + 1;\n          // Stop at the last item instead of wrapping\n          if (nextIndex >= buttons.length) return;\n          if (nextIndex < 0) nextIndex = 0;\n\n          buttons[nextIndex]?.focus();\n          break;\n        }\n\n        case 'ArrowUp': {\n          e.preventDefault();\n          // Open menu when arrow key is pressed\n          void autocomplete.openMenu();\n\n          let prevIndex = currentIndex - 1;\n          // Stop at the first item instead of wrapping\n          if (prevIndex < 0) return;\n\n          buttons[prevIndex]?.focus();\n          break;\n        }\n\n        case 'Enter': {\n          e.preventDefault();\n          // If a button is focused, click it\n          if (buttons.includes(currentFocusedButton)) {\n            currentFocusedButton.click();\n          }\n          const input = autocomplete.querySelector('input');\n          input?.focus();\n          break;\n        }\n\n        case 'Escape': {\n          e.preventDefault();\n          void autocomplete.closeMenu();\n          // Return focus to input\n          const input = autocomplete.querySelector('input');\n          input?.focus();\n          break;\n        }\n      }\n    };\n\n    const handleInputChange = (e: CustomEvent<Event>) => {\n      if (!e.detail?.target) return;\n\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      ) as Element & { noResults: IAutocompleteNoResults };\n\n      if (autocomplete) {\n        const searchText = (\n          e.detail.target as HTMLInputElement\n        ).value.toLowerCase();\n\n        const menuItems = autocomplete?.querySelectorAll('modus-wc-menu-item');\n\n        // Clear selected state when input is empty\n        if (searchText === '') {\n          menuItems?.forEach((item) => {\n            item.removeAttribute('selected');\n          });\n        }\n\n        let hiddenCount = 0;\n        Array.from(menuItems ?? []).forEach((menuItem) => {\n          const label = menuItem.getAttribute('label')?.toLowerCase() || '';\n          if (!label.includes(searchText)) {\n            menuItem.classList.add('hidden');\n            hiddenCount++;\n          } else {\n            menuItem.classList.remove('hidden');\n          }\n        });\n\n        // Show no results if all items are hidden\n        autocomplete.noResults =\n          hiddenCount === menuItems?.length\n            ? originalNoResults\n            : { ariaLabel: '', label: '', subLabel: '' };\n\n        // Show/hide the no results element\n        const noResultsElement = autocomplete.querySelector(\n          '.no-results-item'\n        ) as HTMLElement;\n        if (noResultsElement) {\n          if (hiddenCount === menuItems?.length) {\n            noResultsElement.classList.add('visible');\n          } else {\n            noResultsElement.classList.remove('visible');\n          }\n        }\n      }\n    };\n\n    const handleItemSelect = (e: CustomEvent<{ value: string }>) => {\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      ) as HTMLElement & { value: string; closeMenu: () => Promise<void> };\n\n      if (autocomplete) {\n        const selectedValue = e.detail.value;\n        autocomplete.value = selectedValue;\n        // Update selected state on menu items\n        const menuItems = autocomplete.querySelectorAll('modus-wc-menu-item');\n        menuItems.forEach((item) => {\n          if (item.getAttribute('value') === selectedValue) {\n            item.setAttribute('selected', 'true');\n          } else {\n            item.removeAttribute('selected');\n          }\n        });\n        // Close menu after selection unless leaveMenuOpen is true\n        if (!args['leave-menu-open']) {\n          void autocomplete.closeMenu();\n        }\n      }\n    };\n    // prettier-ignore\n    return html`\n<script>\nconst originalNoResults = args['no-results'];\nif (args['leave-menu-open'] == true) {\n  args['no-results'] = {\n    ariaLabel: '',\n    label: '',\n    subLabel: '',\n  };\n}\n\nconst getVisibleItems = (autocomplete: Element): HTMLElement[] => {\n  const menuItems = autocomplete.querySelectorAll(\n    'modus-wc-menu-item:not([disabled])'\n  );\n  return Array.from(menuItems).filter(\n    (item: Element): item is HTMLElement => {\n      const style = window.getComputedStyle(item);\n      return style.display !== 'none' && !item.classList.contains('hidden');\n    }\n  );\n};\n\nconst handleCustomKeyDown = (e: KeyboardEvent) => {\n  const autocomplete = (e.target as HTMLInputElement).closest(\n    'modus-wc-autocomplete'\n  ) as Element & {\n    openMenu: () => Promise<void>;\n    closeMenu: () => Promise<void>;\n    readOnly?: boolean;\n    disabled?: boolean;\n  };\n  if (!autocomplete) return;\n\n  // Don't process keyboard events when disabled or readOnly\n  if (autocomplete.disabled || autocomplete.readOnly) return;\n\n  const visibleItems = getVisibleItems(autocomplete);\n\n  // Get all button elements within visible menu items\n  const buttons = visibleItems\n    .map((item) => item.querySelector('button'))\n    .filter(Boolean) as HTMLButtonElement[];\n  const currentFocusedButton = document.activeElement as HTMLButtonElement;\n  const currentIndex = buttons.indexOf(currentFocusedButton);\n\n  switch (e.key) {\n    case 'ArrowDown': {\n      e.preventDefault();\n      // Open menu when arrow key is pressed\n      void autocomplete.openMenu();\n\n      let nextIndex = currentIndex + 1;\n      // Stop at the last item instead of wrapping\n      if (nextIndex >= buttons.length) return;\n      if (nextIndex < 0) nextIndex = 0;\n\n      buttons[nextIndex]?.focus();\n      break;\n    }\n\n    case 'ArrowUp': {\n      e.preventDefault();\n      // Open menu when arrow key is pressed\n      void autocomplete.openMenu();\n\n      let prevIndex = currentIndex - 1;\n      // Stop at the first item instead of wrapping\n      if (prevIndex < 0) return;\n\n      buttons[prevIndex]?.focus();\n      break;\n    }\n\n    case 'Enter': {\n      e.preventDefault();\n      // If a button is focused, click it\n      if (buttons.includes(currentFocusedButton)) {\n        currentFocusedButton.click();\n      }\n      break;\n    }\n\n    case 'Escape': {\n      e.preventDefault();\n      void autocomplete.closeMenu();\n      // Return focus to input\n      const input = autocomplete.querySelector('input');\n      input?.focus();\n      break;\n    }\n  }\n};\n\nconst handleInputChange = (e: CustomEvent<Event>) => {\n  if (!e.detail?.target) return;\n\n  const autocomplete = (e.target as HTMLInputElement).closest(\n    'modus-wc-autocomplete'\n  ) as Element & { noResults: IAutocompleteNoResults };\n\n  if (autocomplete) {\n    const searchText = (\n      e.detail.target as HTMLInputElement\n    ).value.toLowerCase();\n    const menuItems = autocomplete?.querySelectorAll('modus-wc-menu-item');\n\n    // Clear selected state when input is empty\n    if (searchText === '') {\n      menuItems?.forEach((item) => {\n        item.removeAttribute('selected');\n      });\n    }\n\n    let hiddenCount = 0;\n    Array.from(menuItems ?? []).forEach((menuItem) => {\n      const label = menuItem.getAttribute('label')?.toLowerCase() || '';\n      if (!label.includes(searchText)) {\n        menuItem.classList.add('hidden');\n        hiddenCount++;\n      } else {\n        menuItem.classList.remove('hidden');\n      }\n    });\n\n    // Show no results if all items are hidden\n    autocomplete.noResults =\n      hiddenCount === menuItems?.length\n        ? originalNoResults\n        : { ariaLabel: '', label: '', subLabel: '' };\n\n    // Show/hide the no results element\n    const noResultsElement = autocomplete.querySelector('.no-results-item') as HTMLElement;\n    if (noResultsElement) {\n      if (hiddenCount === menuItems?.length) {\n        noResultsElement.classList.add('visible');\n      } else {\n        noResultsElement.classList.remove('visible');\n      }\n    }\n  }\n};\n\nconst handleItemSelect = (e: CustomEvent<{ value: string }>) => {\n  const autocomplete = (e.target as HTMLInputElement).closest(\n    'modus-wc-autocomplete'\n  ) as HTMLElement & { value: string; closeMenu: () => Promise<void> };\n\n  if (autocomplete) {\n    const selectedValue = e.detail.value;\n    autocomplete.value = selectedValue;\n    // Update selected state on menu items\n    const menuItems = autocomplete.querySelectorAll('modus-wc-menu-item');\n    menuItems.forEach((item) => {\n      if (item.getAttribute('value') === selectedValue) {\n        item.setAttribute('selected', 'true');\n      } else {\n        item.removeAttribute('selected');\n      }\n    });\n    // Close menu after selection unless leaveMenuOpen is true\n    if (!args['leave-menu-open']) {\n      void autocomplete.closeMenu();\n    }\n  }\n};\n</script>\n<style>\ndiv[id^='story--components-forms-autocomplete--custom-menu-items'] {\n  height: 400px;\n}\n.modus-wc-autocomplete {\n    width: 480px !important;\n  }\n.custom-menu-content {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  width: 100%;\n}\n.content-wrapper {\n  flex: 1;\n}\n.title {\n  font-weight: 500;\n}\n.subtitle {\n  font-size: 0.875rem;\n  color: #666;\n}\nmodus-wc-menu-item.hidden {\n  display: none;\n}\n.no-results-item {\n  display: none;\n  padding: 16px;\n  text-align: center;\n}\n.no-results-item.visible {\n  display: block;\n}\n.no-results-header {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n  margin-bottom: 8px;\n}\n.no-results-title {\n  font-weight: bold;\n}\n.no-results-header modus-wc-icon {\n  color: var(--modus-wc-color-gray-6);\n}\n\n</style>\n<modus-wc-autocomplete\n  aria-label=\"Custom menu items example\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  min-chars=${args['min-chars']}\n  ?multi-select=${false}\n  name=${ifDefined(args.name)}\n  .noResults=${args['no-results']}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  size=${ifDefined(args.size)}\n  ?show-spinner=${args['show-spinner']}\n  value=${args.value}\n  .customKeyDown=${handleCustomKeyDown}\n  @inputChange=${handleInputChange}\n  ?include-search=${true}\n>\n  <div slot=\"menu-items\">\n    <modus-wc-menu-item\n      label=\"John Doe\"\n      sub-label=\"john.doe@example.com\"\n      value=\"John Doe\"\n      @itemSelect=${handleItemSelect}\n    >\n           <div slot=\"start-icon\">\n      <modus-wc-avatar aria-label=\"Avatar\" size=\"xs\" img-src=\"https://i.pinimg.com/474x/73/54/79/7354794bf3873c3ef2666f778da4bcac.jpg\" shape=\"circle\" size=\"xs\"></modus-wc-avatar>\n      </div>\n    </modus-wc-menu-item>\n    <modus-wc-menu-item\n      label=\"Jane Smith\"\n      sub-label=\"jane.smith@example.com\"\n      value=\"Jane Smith\"\n      @itemSelect=${handleItemSelect}\n    >\n      <div slot=\"start-icon\">\n      <modus-wc-avatar aria-label=\"Avatar\" size=\"xs\" img-src=\"https://i.pinimg.com/474x/73/54/79/7354794bf3873c3ef2666f778da4bcac.jpg\" shape=\"circle\" size=\"xs\"></modus-wc-avatar>\n      </div>\n    </modus-wc-menu-item>\n    <modus-wc-menu-item\n      label=\"Bob Johnson\"\n      sub-label=\"bob.johnson@example.com\"\n      value=\"Bob Johnson\"\n      @itemSelect=${handleItemSelect}\n    >\n                <div slot=\"start-icon\">\n      <modus-wc-avatar aria-label=\"Avatar\" size=\"xs\" img-src=\"https://i.pinimg.com/474x/73/54/79/7354794bf3873c3ef2666f778da4bcac.jpg\" shape=\"circle\" size=\"xs\"></modus-wc-avatar>\n      </div>\n    </modus-wc-menu-item>\n    <modus-wc-menu-item\n      label=\"Alice Williams\"\n      sub-label=\"alice.williams@example.com\"\n      value=\"Alice Williams\"\n      @itemSelect=${handleItemSelect}\n    >\n      <div slot=\"start-icon\">\n      <modus-wc-avatar aria-label=\"Avatar\" size=\"xs\" alt=\"Example avatar\" img-src=\"https://i.pinimg.com/474x/73/54/79/7354794bf3873c3ef2666f778da4bcac.jpg\" shape=\"circle\" size=\"md\"></modus-wc-avatar>\n      </div>\n    </modus-wc-menu-item>\n    <li class=\"no-results-item\">\n      <div class=\"no-results-header\">\n        <modus-wc-icon name=\"search\" size=\"lg\"></modus-wc-icon>\n        <div class=\"no-results-title\">No results found</div>\n      </div>\n    </li>\n  </div>\n</modus-wc-autocomplete>\n    `;\n  },\n};\n\nexport const CustomEventHandlers: Story = {\n  render: (args) => {\n    interface AutocompleteElement extends HTMLElement {\n      items: IAutocompleteItem[];\n      value: string;\n      openMenu(): Promise<void>;\n      closeMenu(): Promise<void>;\n    }\n\n    // Custom keydown handler with skip navigation and escape animation\n    const customKeyDown = (e: KeyboardEvent) => {\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      ) as AutocompleteElement;\n      if (!autocomplete) return;\n\n      // Prevent default for navigation keys\n      if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key)) {\n        e.preventDefault();\n      }\n\n      const visibleItems = args.items.filter(\n        (item) => item.visibleInMenu && !item.disabled\n      );\n\n      switch (e.key) {\n        case 'Escape':\n          args.items = args.items.map((item) => ({\n            ...item,\n            focused: false,\n          }));\n          autocomplete.items = [...args.items];\n          void autocomplete.closeMenu();\n          // Custom: Show escape animation\n          autocomplete.style.transform = 'scale(0.98)';\n          setTimeout(() => {\n            autocomplete.style.transform = '';\n          }, 200);\n          break;\n\n        case 'ArrowDown': {\n          // Open menu if not already open\n          void autocomplete.openMenu();\n\n          const currentIndex = visibleItems.findIndex((item) => item.focused);\n          const nextIndex =\n            currentIndex < 0\n              ? 0\n              : Math.min(currentIndex + 1, visibleItems.length - 1);\n\n          // Custom: Skip every other item for faster navigation\n          const skipIndex =\n            nextIndex + 1 < visibleItems.length ? nextIndex + 1 : nextIndex;\n\n          args.items = args.items.map((item) => ({\n            ...item,\n            focused: visibleItems[skipIndex]?.value === item.value,\n          }));\n          break;\n        }\n\n        case 'ArrowUp': {\n          const currentIndex = visibleItems.findIndex((item) => item.focused);\n          const prevIndex =\n            currentIndex < 0\n              ? visibleItems.length - 1\n              : Math.max(currentIndex - 1, 0);\n\n          // Custom: Skip every other item for faster navigation\n          const skipIndex = prevIndex - 1 >= 0 ? prevIndex - 1 : prevIndex;\n\n          args.items = args.items.map((item) => ({\n            ...item,\n            focused: visibleItems[skipIndex]?.value === item.value,\n          }));\n          break;\n        }\n\n        case 'Enter': {\n          const focusedItem = visibleItems.find((item) => item.focused);\n          if (focusedItem) {\n            // For single select, clear previous selection\n            args.items = args.items.map((item) => ({\n              ...item,\n              selected: item.value === focusedItem.value,\n              focused: false,\n            }));\n            autocomplete.value = focusedItem.label;\n            void autocomplete.closeMenu();\n          }\n          break;\n        }\n\n        default:\n          return;\n      }\n\n      autocomplete.items = [...args.items];\n    };\n\n    // Custom input change handler with fuzzy character matching\n    const customInputChange = (value: string) => {\n      const autocomplete = document.querySelector(\n        'modus-wc-autocomplete'\n      ) as AutocompleteElement;\n      if (!autocomplete) return;\n\n      const searchChars = value.toLowerCase().split('');\n\n      // Custom fuzzy search: Match items that contain ALL typed characters (in any order)\n      if (value.length > 0) {\n        // Calculate match score for each item\n        const scoredItems = args.items.map((item) => {\n          const itemLower = item.label.toLowerCase();\n          let score = 0;\n          let allCharsFound = true;\n\n          // Check if all search characters exist in the item\n          for (const char of searchChars) {\n            if (itemLower.includes(char)) {\n              // Bonus points for consecutive characters\n              const charIndex = itemLower.indexOf(char);\n              if (charIndex === 0)\n                score += 3; // Start of word bonus\n              else if (itemLower[charIndex - 1] === ' ')\n                score += 2; // Start of any word\n              else score += 1;\n            } else {\n              allCharsFound = false;\n              break;\n            }\n          }\n\n          // Additional bonus for exact substring match\n          if (allCharsFound && itemLower.includes(value.toLowerCase())) {\n            score += 10;\n          }\n\n          return {\n            item,\n            score: allCharsFound ? score : -1,\n            visible: allCharsFound,\n          };\n        });\n\n        // Sort by score (highest first) and update items\n        scoredItems.sort((a, b) => b.score - a.score);\n        args.items = scoredItems.map(({ item, visible }) => ({\n          ...item,\n          visibleInMenu: visible,\n          focused: false,\n          selected: item.selected && visible,\n          // Add score as part of label for demonstration (you can remove this in production)\n          label: item.label,\n        }));\n      } else {\n        // No search text, show all items\n        args.items = args.items.map((item) => ({\n          ...item,\n          visibleInMenu: true,\n          focused: false,\n        }));\n      }\n\n      autocomplete.items = [...args.items];\n      autocomplete.value = value;\n      // Show match count in console for demonstration\n      const matchCount = args.items.filter((item) => item.visibleInMenu).length;\n      console.log(`Fuzzy search for \"${value}\": ${matchCount} matches found`);\n\n      // Show menu if there are visible items\n      const hasVisibleItems = args.items.some((item) => item.visibleInMenu);\n      if (hasVisibleItems && value.length >= args['min-chars']) {\n        void autocomplete.openMenu();\n      } else {\n        void autocomplete.closeMenu();\n      }\n    };\n\n    // Custom item select handler\n    const customItemSelect = (item: IAutocompleteItem) => {\n      const autocomplete = document.querySelector(\n        'modus-wc-autocomplete'\n      ) as AutocompleteElement;\n      if (!autocomplete) return;\n\n      // Clear previous selections for single select\n      args.items = args.items.map((menuItem) => ({\n        ...menuItem,\n        selected: menuItem.value === item.value,\n        focused: false,\n      }));\n\n      autocomplete.items = [...args.items];\n      autocomplete.value = item.label;\n      void autocomplete.closeMenu();\n    };\n\n    return html`\n      <style>\n        div[id^='story--components-forms-autocomplete--custom-event-handlers'] {\n          height: 400px;\n        }\n\n        .modus-wc-autocomplete.modus-wc-autocomplete {\n          width: 300px;\n        }\n\n        .fuzzy-info {\n          margin-top: 1rem;\n          padding: 1rem;\n          background-color: var(--modus-wc-color-info-light);\n          border-radius: 4px;\n          font-size: 0.875rem;\n        }\n      </style>\n\n      <modus-wc-autocomplete\n        aria-label=\"Custom handlers autocomplete\"\n        ?bordered=${args.bordered}\n        custom-class=${ifDefined(args['custom-class'])}\n        debounce-ms=${0}\n        ?disabled=${args.disabled}\n        ?include-clear=${args['include-clear']}\n        ?include-search=${args['include-search']}\n        input-id=${ifDefined(args['input-id'])}\n        input-tab-index=${ifDefined(args['input-tab-index'])}\n        .items=${args.items}\n        label=\"Fruit list with custom handlers\"\n        ?leave-menu-open=${args['leave-menu-open']}\n        min-chars=${args['min-chars']}\n        ?multi-select=${false}\n        name=${ifDefined(args.name)}\n        .noResults=${args['no-results']}\n        placeholder=\"Type 'bry' for Blueberry or Raspberry\"\n        ?read-only=${args['read-only']}\n        ?required=${args.required}\n        ?show-menu-on-focus=${args['show-menu-on-focus']}\n        ?show-spinner=${args['show-spinner']}\n        size=${ifDefined(args.size)}\n        value=${args.value}\n        .customKeyDown=${customKeyDown}\n        .customInputChange=${customInputChange}\n        .customItemSelect=${customItemSelect}\n      ></modus-wc-autocomplete>\n    `;\n  },\n  args: {\n    bordered: true,\n    'debounce-ms': 0, // Set to 0 to see immediate feedback\n    disabled: false,\n    'include-clear': true,\n    'include-search': true,\n    items: items,\n    'leave-menu-open': false,\n    'min-chars': 0,\n    'no-results': {\n      label: 'No fruits found',\n      subLabel: 'Try different characters',\n    },\n    placeholder: 'Search fruits...',\n    'read-only': false,\n    required: false,\n    'show-menu-on-focus': true,\n    'show-spinner': false,\n    size: 'md',\n    value: '',\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: `This example demonstrates custom event handlers with three specific behaviors:\n\n1. **Skip Navigation**: Arrow keys skip every other item for 2x faster navigation\n2. **Escape Animation**: Pressing Escape triggers a subtle scale animation\n3. **Fuzzy Character Search**: Instead of normal substring matching, this searches for items containing ALL typed characters in any order\n\nThe fuzzy search allows finding items with scattered characters:\n- Type \"pae\" to find Pine**a**ppl**e**\n- Type \"bry\" to find Blue**b**er**ry**, Straw**b**er**ry**, Rasp**b**er**ry**\n\nItems are automatically sorted by relevance with exact substring matches appearing first.`,\n      },\n    },\n  },\n};\n\nexport const WithProgrammaticControl: Story = {\n  args: {\n    ...meta.args,\n    items: items, // Explicitly set items for this story\n  },\n  render: (args) => {\n    // Type for autocomplete element with methods\n    interface AutocompleteElement extends HTMLElement {\n      selectItem(item: IAutocompleteItem | null): Promise<void>;\n      openMenu(): Promise<void>;\n      closeMenu(): Promise<void>;\n      toggleMenu(): Promise<void>;\n      focusInput(): Promise<void>;\n      clearInput(): Promise<void>;\n    }\n\n    // Handler functions that will be attached to buttons\n    const handleSelectApple = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        const appleItem = items.find((item) => item.value === 'apple') || null;\n        await autocomplete.selectItem(appleItem);\n      }\n    };\n\n    const handleSelectNull = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        await autocomplete.selectItem(null);\n      }\n    };\n\n    const handleOpenMenu = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        await autocomplete.openMenu();\n      }\n    };\n\n    const handleCloseMenu = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        await autocomplete.closeMenu();\n      }\n    };\n\n    const handleToggleMenu = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        await autocomplete.toggleMenu();\n      }\n    };\n\n    const handleFocusInput = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        await autocomplete.focusInput();\n      }\n    };\n\n    const handleClearInput = async () => {\n      const autocomplete = document.getElementById(\n        'programmatic-autocomplete'\n      ) as AutocompleteElement;\n      if (autocomplete) {\n        await autocomplete.clearInput();\n      }\n    };\n\n    // Attach handlers to window for inline onclick\n    interface WindowWithHandlers extends Window {\n      handleSelectApple?: () => Promise<void>;\n      handleSelectNull?: () => Promise<void>;\n      handleOpenMenu?: () => Promise<void>;\n      handleCloseMenu?: () => Promise<void>;\n      handleToggleMenu?: () => Promise<void>;\n      handleFocusInput?: () => Promise<void>;\n      handleClearInput?: () => Promise<void>;\n    }\n\n    const windowWithHandlers = window as WindowWithHandlers;\n    windowWithHandlers.handleSelectApple = handleSelectApple;\n    windowWithHandlers.handleSelectNull = handleSelectNull;\n    windowWithHandlers.handleOpenMenu = handleOpenMenu;\n    windowWithHandlers.handleCloseMenu = handleCloseMenu;\n    windowWithHandlers.handleToggleMenu = handleToggleMenu;\n    windowWithHandlers.handleFocusInput = handleFocusInput;\n    windowWithHandlers.handleClearInput = handleClearInput;\n\n    return html`\n      <style>\n        div[id^='story--components-forms-autocomplete--with-programmatic-control'] {\n          height: 500px;\n        }\n\n        .controls-content {\n          display: flex;\n          flex-direction: column;\n          gap: 1rem;\n        }\n        .control-group {\n          margin-bottom: 1rem;\n        }\n        .control-group label {\n          display: block;\n          margin-bottom: 0.5rem;\n          font-weight: 600;\n        }\n        .button-row {\n          display: flex;\n          gap: 0.5rem;\n          flex-wrap: wrap;\n        }\n      </style>\n\n      <modus-wc-card class=\"controls-card\">\n        <div class=\"controls-content\">\n          <h3>Programmatic Control Methods</h3>\n\n          <div class=\"control-group\">\n            <label>Selection Methods:</label>\n            <div class=\"button-row\">\n              <modus-wc-button\n                onclick=\"window.handleSelectApple()\"\n                variant=\"primary\"\n                size=\"sm\"\n              >\n                Select Apple\n              </modus-wc-button>\n              <modus-wc-button\n                onclick=\"window.handleSelectNull()\"\n                variant=\"secondary\"\n                size=\"sm\"\n              >\n                Clear Selection\n              </modus-wc-button>\n            </div>\n          </div>\n\n          <div class=\"control-group\">\n            <label>Menu Control Methods:</label>\n            <div class=\"button-row\">\n              <modus-wc-button\n                onclick=\"window.handleOpenMenu()\"\n                variant=\"primary\"\n                size=\"sm\"\n              >\n                Open Menu\n              </modus-wc-button>\n              <modus-wc-button\n                onclick=\"window.handleCloseMenu()\"\n                variant=\"primary\"\n                size=\"sm\"\n              >\n                Close Menu\n              </modus-wc-button>\n              <modus-wc-button\n                onclick=\"window.handleToggleMenu()\"\n                variant=\"secondary\"\n                size=\"sm\"\n              >\n                Toggle Menu\n              </modus-wc-button>\n            </div>\n          </div>\n\n          <div class=\"control-group\">\n            <label>Input Control Methods:</label>\n            <div class=\"button-row\">\n              <modus-wc-button\n                onclick=\"window.handleFocusInput()\"\n                variant=\"primary\"\n                size=\"sm\"\n              >\n                Focus Input\n              </modus-wc-button>\n              <modus-wc-button\n                onclick=\"window.handleClearInput()\"\n                variant=\"danger\"\n                size=\"sm\"\n              >\n                Clear All\n              </modus-wc-button>\n            </div>\n          </div>\n        </div>\n      </modus-wc-card>\n\n      <modus-wc-autocomplete\n        id=\"programmatic-autocomplete\"\n        aria-label=\"Programmatic control demo\"\n        ?bordered=${args.bordered}\n        custom-class=${ifDefined(args['custom-class'])}\n        debounce-ms=${ifDefined(args['debounce-ms'])}\n        ?disabled=${args.disabled}\n        ?include-clear=${args['include-clear']}\n        ?include-search=${args['include-search']}\n        input-id=${ifDefined(args['input-id'])}\n        input-tab-index=${ifDefined(args['input-tab-index'])}\n        .items=${args.items}\n        label=\"Try the control buttons above\"\n        ?leave-menu-open=${args['leave-menu-open']}\n        max-chips=${args['max-chips'] ?? 4}\n        min-chars=${args['min-chars']}\n        min-input-width=${ifDefined(args['min-input-width'])}\n        ?multi-select=${args['multi-select']}\n        name=${ifDefined(args.name)}\n        .noResults=${args['no-results']}\n        placeholder=\"Use buttons above to control\"\n        ?read-only=${args['read-only']}\n        ?required=${args.required}\n        ?show-menu-on-focus=${args['show-menu-on-focus']}\n        ?show-spinner=${args['show-spinner']}\n        size=${ifDefined(args.size)}\n        value=${args.value}\n      ></modus-wc-autocomplete>\n    `;\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: `\n## Public Methods\n\nThe autocomplete component exposes several methods that can be called programmatically:\n\n### selectItem(item: IAutocompleteItem | null): Promise<void>\nProgrammatically select an item. Pass \\`null\\` to clear selection.\n\n\\`\\`\\`javascript\nconst autocomplete = document.querySelector('modus-wc-autocomplete');\nconst item = { label: 'Apple', value: 'apple', visibleInMenu: true };\nawait autocomplete.selectItem(item);\n\\`\\`\\`\n\n### openMenu(): Promise<void>\nProgrammatically open the dropdown menu.\n\n\\`\\`\\`javascript\nawait autocomplete.openMenu();\n\\`\\`\\`\n\n### closeMenu(): Promise<void>\nProgrammatically close the dropdown menu.\n\n\\`\\`\\`javascript\nawait autocomplete.closeMenu();\n\\`\\`\\`\n\n### toggleMenu(): Promise<void>\nToggle the dropdown menu open/closed.\n\n\\`\\`\\`javascript\nawait autocomplete.toggleMenu();\n\\`\\`\\`\n\n### focusInput(): Promise<void>\nSet focus to the input element.\n\n\\`\\`\\`javascript\nawait autocomplete.focusInput();\n\\`\\`\\`\n\n### clearInput(): Promise<void>\nClear the input value and all selections.\n\n\\`\\`\\`javascript\nawait autocomplete.clearInput();\n\\`\\`\\`\n\n        `,\n      },\n    },\n  },\n};\n\nexport const DynamicOptions: Story = {\n  render: (args) => {\n    const defaultFruits = [\n      { label: 'Apple', value: 'apple', visibleInMenu: true },\n      { label: 'Banana', value: 'banana', visibleInMenu: true },\n      { label: 'Orange', value: 'orange', visibleInMenu: true },\n      { label: 'Strawberry', value: 'strawberry', visibleInMenu: true },\n    ];\n\n    // Extended dataset that will be searched when typing\n    const allFruits = [\n      ...defaultFruits,\n      { label: 'Blackberry', value: 'blackberry', visibleInMenu: true },\n      { label: 'Blueberry', value: 'blueberry', visibleInMenu: true },\n      { label: 'Cherry', value: 'cherry', visibleInMenu: true },\n      { label: 'Cranberry', value: 'cranberry', visibleInMenu: true },\n      { label: 'Fig', value: 'fig', visibleInMenu: true },\n      { label: 'Grape', value: 'grape', visibleInMenu: true },\n      { label: 'Kiwi', value: 'kiwi', visibleInMenu: true },\n      { label: 'Lemon', value: 'lemon', visibleInMenu: true },\n      { label: 'Lime', value: 'lime', visibleInMenu: true },\n      { label: 'Mango', value: 'mango', visibleInMenu: true },\n      { label: 'Melon', value: 'melon', visibleInMenu: true },\n      { label: 'Peach', value: 'peach', visibleInMenu: true },\n      { label: 'Pineapple', value: 'pineapple', visibleInMenu: true },\n      { label: 'Raspberry', value: 'raspberry', visibleInMenu: true },\n      { label: 'Watermelon', value: 'watermelon', visibleInMenu: true },\n    ];\n\n    const handleInputChange = (e: CustomEvent<Event>) => {\n      if (!e.detail?.target) return;\n\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      );\n\n      if (autocomplete) {\n        const input = e.detail.target as HTMLInputElement;\n        const searchText = input.value.toLowerCase();\n\n        if (searchText === '') {\n          autocomplete.items = [...defaultFruits];\n          autocomplete.value = input.value;\n          return;\n        }\n\n        autocomplete.showSpinner = true;\n        setTimeout(() => {\n          const filteredFruits = allFruits.filter((fruit) =>\n            fruit.label.toLowerCase().includes(searchText)\n          );\n\n          autocomplete.items = filteredFruits;\n          autocomplete.showSpinner = false;\n        }, 1000);\n\n        autocomplete.value = input.value;\n      }\n    };\n\n    const handleItemSelect = (e: CustomEvent<IAutocompleteItem>) => {\n      const autocomplete = (e.target as HTMLInputElement).closest(\n        'modus-wc-autocomplete'\n      );\n\n      if (autocomplete) {\n        const label = e.detail.label;\n        if (label) {\n          autocomplete.value = label;\n        }\n      }\n    };\n\n    return html`\n      <style>\n        div[id^='story--components-forms-autocomplete--dynamic-options'] {\n          height: 400px;\n        }\n      </style>\n      <script>\n          const defaultFruits = [\n          { label: 'Apple', value: 'apple', visibleInMenu: true },\n          { label: 'Banana', value: 'banana', visibleInMenu: true },\n          { label: 'Orange', value: 'orange', visibleInMenu: true },\n          { label: 'Strawberry', value: 'strawberry', visibleInMenu: true },\n        ];\n\n        // Extended dataset that will be searched when typing\n        const allFruits = [\n          ...defaultFruits,\n          { label: 'Blackberry', value: 'blackberry', visibleInMenu: true },\n          { label: 'Blueberry', value: 'blueberry', visibleInMenu: true },\n          { label: 'Cherry', value: 'cherry', visibleInMenu: true },\n          { label: 'Cranberry', value: 'cranberry', visibleInMenu: true },\n          { label: 'Fig', value: 'fig', visibleInMenu: true },\n          { label: 'Grape', value: 'grape', visibleInMenu: true },\n          { label: 'Kiwi', value: 'kiwi', visibleInMenu: true },\n          { label: 'Lemon', value: 'lemon', visibleInMenu: true },\n          { label: 'Lime', value: 'lime', visibleInMenu: true },\n          { label: 'Mango', value: 'mango', visibleInMenu: true },\n          { label: 'Melon', value: 'melon', visibleInMenu: true },\n          { label: 'Peach', value: 'peach', visibleInMenu: true },\n          { label: 'Pineapple', value: 'pineapple', visibleInMenu: true },\n          { label: 'Raspberry', value: 'raspberry', visibleInMenu: true },\n          { label: 'Watermelon', value: 'watermelon', visibleInMenu: true },\n        ];\n\n        const handleInputChange = (e: CustomEvent<Event>) => {\n          if (!e.detail?.target) return;\n\n          const autocomplete = (e.target as HTMLInputElement).closest(\n            'modus-wc-autocomplete'\n          );\n\n          if (autocomplete) {\n            const input = e.detail.target as HTMLInputElement;\n            const searchText = input.value.toLowerCase();\n\n            // // If empty, show default fruits again\n            if (searchText === '') {\n              autocomplete.items = [...defaultFruits];\n              autocomplete.value = input.value;\n              return;\n            }\n\n            // Show spinner while \"loading\" data\n            autocomplete.showSpinner = true;\n\n            // Simulate API call delay with setTimeout\n            setTimeout(() => {\n              const filteredFruits = allFruits.filter((fruit) =>\n                fruit.label.toLowerCase().includes(searchText)\n              );\n\n              // Update the items with the \"API response\"\n              autocomplete.items = filteredFruits;\n\n              // Hide spinner after \"loading\" completes\n              autocomplete.showSpinner = false;\n            }, 1000);\n\n            autocomplete.value = input.value;\n          }\n        };\n\n        const handleItemSelect = (e: CustomEvent<IAutocompleteItem>) => {\n          const autocomplete = (e.target as HTMLInputElement).closest(\n            'modus-wc-autocomplete'\n          );\n\n          if (autocomplete) {\n            const label = e.detail.label;\n            if (label) {\n              autocomplete.value = label;\n            }\n          }\n        };\n      </script>\n      <modus-wc-autocomplete\n        aria-label=\"Dynamic fruits autocomplete\"\n        ?bordered=${args.bordered}\n        custom-class=${ifDefined(args['custom-class'])}\n        debounce-ms=${ifDefined(args['debounce-ms'])}\n        ?disabled=${args.disabled}\n        input-id=${ifDefined(args['input-id'])}\n        input-tab-index=${ifDefined(args['input-tab-index'])}\n        .items=${defaultFruits}\n        label=${ifDefined(args.label)}\n        ?leave-menu-open=${args['leave-menu-open']}\n        min-chars=${0}\n        ?multi-select=${false}\n        name=${ifDefined(args.name)}\n        .noResults=${args['no-results']}\n        placeholder=\"Type to search fruits...\"\n        ?read-only=${args['read-only']}\n        ?required=${args.required}\n        ?show-menu-on-focus=${true}\n        size=${ifDefined(args.size)}\n        value=${args.value}\n        @inputChange=${handleInputChange}\n        @itemSelect=${handleItemSelect}\n      ></modus-wc-autocomplete>\n    `;\n  },\n};\n\nexport const Migration: Story = {\n  parameters: {\n    docs: {\n      description: {\n        story: `\n#### Breaking Changes\n\n  - In 1.0 input state was maintained by the component. 2.0 components encourage users to follow a controlled\n  input model. See the Form Inputs [documentation]([Angular](?path=/docs/documentation-form-inputs--docs) for\n  additional info and examples.\n  - To handle updating items in 2.0, simply create a new array of items and bind it to the \\`items\\` prop. The 1.0 prop\n  \\`filter-options\\` is no longer necessary.\n  - Size values have changed from verbose names (\\`small\\`, \\`medium\\`, \\`large\\`) to abbreviations (\\`sm\\`, \\`md\\`, \\`lg\\`).\n\n#### Prop Mapping\n\n| 1.0 Prop                      | 2.0 Prop            | Notes                                                       |\n|-------------------------------|---------------------|-------------------------------------------------------------|\n| aria-label                    | aria-label          |                                                             |\n| clearable                     |                     | Upcoming feature                                            |\n| disabled                      | disabled            |                                                             |\n| disable-close-on-select       | leave-menu-open     |                                                             |\n| dropdown-max-height           |                     | Not carried over, use CSS instead                           |\n| dropdown-z-index              |                     | Not carried over, use CSS instead                           |\n| error-text                    | feedback.message    | Use feedback level                                          |\n| filter-options                |                     | Rebind options                                              |\n| include-search-icon           |                     | Coming soon                                                 |\n| label                         | label               |                                                             |\n| loading                       |                     | Upcoming feature                                            |\n| multiple                      | multi-select        |                                                             |\n| no-results-found-text         | no-results.label    |                                                             |\n| no-results-found-subtext      | no-results.subLabel |                                                             |\n| options                       | items               |                                                             |\n| placeholder                   | placeholder         |                                                             |\n| read-only                     | read-only           |                                                             |\n| required                      | required            |                                                             |\n| show-no-results-found-message |                     | Not carried over, use \\`no-results\\` prop                   |\n| show-options-on-focus         |                     | Not carried over                                            |\n| size                          | size                | \\`small\\` \u2192 \\`sm\\`, \\`medium\\` \u2192 \\`md\\`, \\`large\\` \u2192 \\`lg\\` |\n| value                         | value               |                                                             |\n\n#### Event Mapping\n\n| 1.0 Event   | 2.0 Event   | Notes            |\n|-------------|-------------|------------------|\n| optionSelected ||\n| selectionsChanged ||\n| valueChange | inputChange |                  |\n\n#### Interfaces\n\n##### 1.0\n\n\\`\\`\\`typescript\ninterface ModusAutocompleteOption {\n  id: string;\n  value: string;\n}\n\\`\\`\\`\n\n##### 2.0\n\n\\`\\`\\`typescript\ninterface IAutocompleteItem {\n  label: string;\n  selected?: boolean;\n  value: string;\n  visibleInMenu: boolean;\n}\n\\`\\`\\`\n        `,\n      },\n    },\n    // To hide the actual story rendering and only show docs:\n    controls: { disable: true },\n    canvas: { disable: true },\n  },\n  // Simple render function or leave it empty\n  render: () => html`<div></div>`,\n};\n",
  "storybook": {
    "examples": [
      "<modus-wc-autocomplete\n  aria-label=\"Fruit autocomplete\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  ?include-clear=${args['include-clear']}\n  ?include-search=${args['include-search']}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  .items=${args.items}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  min-chars=${args['min-chars']}\n  min-input-width=${ifDefined(args['min-input-width'])}\n  ?multi-select=${false}\n  name=${ifDefined(args.name)}\n  .noResults=${args['no-results']}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  ?show-spinner=${args['show-spinner']}\n  size=${ifDefined(args.size)}\n  value=${args.value}\n></modus-wc-autocomplete>",
      "<modus-wc-icon slot=\"custom-icon\" name=\"heart\" size=\"sm\"></modus-wc-icon>",
      "<modus-wc-autocomplete\n  aria-label=\"Fruits with tooltips\"\n  leave-menu-open=\"true\"\n  placeholder=\"Search fruits\"\n  .items={tooltipItems}\n  min-chars=\"0\"\n></modus-wc-autocomplete>",
      "<modus-wc-autocomplete\n          aria-label=\"Fruits with tooltips\"\n          leave-menu-open=\"true\"\n          placeholder=\"Search fruits\"\n          .items=${tooltipItems}\n          min-chars=\"0\"\n        ></modus-wc-autocomplete>",
      "<modus-wc-autocomplete\n  aria-label=\"Fruit autocomplete\"\n  ?bordered=${args.bordered}\n  custom-class=${ifDefined(args['custom-class'])}\n  debounce-ms=${ifDefined(args['debounce-ms'])}\n  ?disabled=${args.disabled}\n  ?include-clear=${args['include-clear']}\n  ?include-search=${args['include-search']}\n  input-id=${ifDefined(args['input-id'])}\n  input-tab-index=${ifDefined(args['input-tab-index'])}\n  .items=${args.items}\n  label=${ifDefined(args.label)}\n  ?leave-menu-open=${args['leave-menu-open']}\n  max-chips=${args['max-chips'] ?? 4}\n  min-chars=${args['min-chars']}\n  min-input-width=${ifDefined(args['min-input-width'])}\n  ?multi-select=${true}\n  name=${ifDefined(args.name)}\n  .noResults=${args['no-results']}\n  placeholder=${ifDefined(args.placeholder)}\n  ?read-only=${args['read-only']}\n  ?required=${args.required}\n  ?show-menu-on-focus=${args['show-menu-on-focus']}\n  size=${ifDefined(args.size)}\n  value=${args.value}\n></modus-wc-autocomplete>"
    ],
    "variants": [
      "secondary",
      "primary",
      "danger"
    ],
    "prop_usage": {
      "label": [
        "Fruit autocomplete",
        "Autocomplete with custom icon",
        "Fruits with tooltips",
        "Fruit autocomplete with spinner",
        "Custom menu items example",
        "John Doe",
        "john.doe@example.com",
        "Avatar",
        "Jane Smith",
        "jane.smith@example.com",
        "Bob Johnson",
        "bob.johnson@example.com",
        "Alice Williams",
        "alice.williams@example.com",
        "Custom handlers autocomplete",
        "Fruit list with custom handlers",
        "Programmatic control demo",
        "Try the control buttons above",
        "Dynamic fruits autocomplete"
      ],
      "slot": [
        "custom-icon",
        "menu-items",
        "start-icon"
      ],
      "name": [
        "heart",
        "search"
      ],
      "size": [
        "sm",
        "xs",
        "md",
        "lg"
      ],
      "open": [
        "true"
      ],
      "placeholder": [
        "Search fruits",
        "Type ",
        "Use buttons above to control",
        "Type to search fruits..."
      ],
      "chars": [
        "0"
      ],
      "style": [
        "width: 300px;"
      ],
      "value": [
        "John Doe",
        "Jane Smith",
        "Bob Johnson",
        "Alice Williams"
      ],
      "src": [
        "https://i.pinimg.com/474x/73/54/79/7354794bf3873c3ef2666f778da4bcac.jpg"
      ],
      "shape": [
        "circle"
      ],
      "alt": [
        "Example avatar"
      ],
      "class": [
        "no-results-item",
        "no-results-header",
        "no-results-title",
        "controls-card",
        "controls-content",
        "control-group",
        "button-row"
      ],
      "onclick": [
        "window.handleSelectApple()",
        "window.handleSelectNull()",
        "window.handleOpenMenu()",
        "window.handleCloseMenu()",
        "window.handleToggleMenu()",
        "window.handleFocusInput()",
        "window.handleClearInput()"
      ],
      "variant": [
        "primary",
        "secondary",
        "danger"
      ],
      "id": [
        "programmatic-autocomplete"
      ]
    }
  },
  "tag_name": "modus-wc-autocomplete"
}